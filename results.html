<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Petanque Results</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f9fa;
      padding: 20px;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center; /* Center the tabs */
    }
    .tab {
      padding: 10px 20px;
      background: #007bff;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold; /* Make tab text bolder */
      transition: background-color 0.3s ease; /* Smooth transition for hover */
    }
    .tab:hover {
      background: #0056b3; /* Darker blue on hover */
    }
    .tab.active {
      background: #0056b3;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add shadow to active tab */
    }
    .tab-content {
      display: none;
      padding: 15px; /* Add some padding to content */
      background: #fff; /* White background for content */
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .tab-content.active {
      display: block;
    }
    h1 {
      text-align: center;
      color: #343a40;
      margin-bottom: 30px;
    }
    h2 {
      color: #007bff;
      border-bottom: 2px solid #007bff;
      padding-bottom: 5px;
      margin-top: 25px;
      margin-bottom: 15px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* Subtle shadow for tables */
    }
    th, td {
      border: 1px solid #ccc;
      text-align: center;
      padding: 10px; /* Increased padding */
    }
    th {
      background: #e9ecef;
      color: #343a40;
      font-weight: bold;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2; /* Zebra striping for tables */
    }
    .match-info, .knockout {
      background: #fff;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .match-info p {
      margin: 5px 0; /* Spacing for match info */
    }
    .match-info .score {
      font-weight: bold;
      color: #dc3545; /* Red for scores */
    }
    .match-info .teams {
      font-size: 1.1em;
      font-weight: bold;
    }
    .venue-time {
      font-style: italic;
      margin-top: 5px;
      color: #6c757d;
      font-size: 0.9em;
    }
    a.back-link {
      display: block;
      margin-top: 30px;
      padding: 10px 20px;
      background: #6c757d; /* Grey background for back link */
      color: white;
      border-radius: 5px;
      text-decoration: none;
      width: fit-content; /* Make button fit content */
      margin-left: auto;
      margin-right: auto;
      transition: background-color 0.3s ease;
    }
    a.back-link:hover {
        background: #5a6268; /* Darker grey on hover */
    }
    /* Specific styling for the Match Matrix table */
    .match-matrix-table td.empty-cell {
        background-color: #eee;
    }
    .match-matrix-table td.score-cell {
        font-weight: bold;
        color: #0056b3;
    }
  </style>
</head>
<body>
  <h1>Petanque Tournament Results</h1>

  <div class="tabs">
    <!-- Group Stage tab - now active by default -->
    <div class="tab active" onclick="switchTab('groupStage')">Group Stage</div>
    <!-- Next Stage tab - now inactive by default -->
    <div class="tab" onclick="switchTab('nextStage')">Next Stage</div>
  </div>

  <!-- Group Stage Content - now active by default -->
  <div id="groupStage" class="tab-content active">
    <h2>Group Stage Tables</h2>
    <div id="groupTables">Loading group tables...</div>
    <h2>Match Matrix</h2>
    <div id="matchMatrix">Loading match matrix...</div>
  </div>

  <!-- Next Stage Content - now inactive by default -->
  <div id="nextStage" class="tab-content">
    <h2>Quarter Final</h2>
    <div class="knockout" id="quarterFinals">Loading Quarter Final matches...</div>

    <h2>Semi Final</h2>
    <div class="knockout" id="semiFinals">Loading Semi Final matches...</div>

    <h2>Final</h2>
    <div class="knockout" id="finalMatch">Loading Final match...</div>

    <a href="index.html" class="back-link">â¬… Back to Main</a>
  </div>

  <script type="module">
    // Firebase configuration and initialization
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, getDoc } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js"; // Added doc and getDoc

    const firebaseConfig = {
      apiKey: "AIzaSyDpS-kqwQDgdqiVK2kwXGB9a3B7WeJI_Iw",
      authDomain: "unimap-petanque.firebaseapp.com",
      projectId: "unimap-petanque",
      storageBucket: "unimap-petanque.appspot.com",
      messagingSenderId: "578920021890",
      appId: "1:578920021890:web:987ed2de28e7b0353c999b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Define groups array, similar to your admin page
    const groups = ["A", "B", "C", "D", "E", "F"];

    /**
     * Function to switch between different tabs (Next Stage, Group Stage).
     * It handles adding/removing 'active' classes for both tab buttons and content.
     * @param {string} tabId - The ID of the tab content to activate (e.g., 'nextStage', 'groupStage').
     */
    // Make switchTab globally accessible
    window.switchTab = function(tabId) {
      // Deactivate all tab buttons
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      // Deactivate all tab content sections
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      
      // Activate the clicked tab button
      document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
      // Activate the corresponding tab content
      document.getElementById(tabId).classList.add('active');
    }

    // --- Firebase Data Fetching Functions ---

    /**
     * Fetches and displays data for the Next Stage (Quarter, Semi, Final).
     * Assumes knockout data is stored in sub-collections like:
     * knockoutMatches/quarter_finals/matches
     * knockoutMatches/semi_finals/matches
     * knockoutMatches/final/matches
     */
    async function fetchNextStageData() {
        try {
            // Quarter Finals
            const quarterFinalsCollection = collection(db, "knockoutMatches", "quarter_finals", "matches");
            const qfSnapshot = await getDocs(quarterFinalsCollection);
            let qfHtml = "<h3>Quarter Finals</h3>";
            if (qfSnapshot.empty) {
                qfHtml += "<p>No Quarter Final matches scheduled or played yet.</p>";
            } else {
                qfSnapshot.forEach(doc => {
                    const match = doc.data();
                    const teamA = match.teamA || "TBD";
                    const teamB = match.teamB || "TBD";
                    const scoreA = match.scoreA !== undefined ? match.scoreA : '';
                    const scoreB = match.scoreB !== undefined ? match.scoreB : '';
                    const venue = match.venue || "TBD";
                    const time = match.time || "TBD";

                    qfHtml += `<div class="match-info">
                                    <p class="teams">${teamA} vs ${teamB}</p>
                                    <p class="score">Score: ${scoreA} - ${scoreB}</p>
                                    <p class="venue-time">Venue: ${venue}, Time: ${time}</p>
                                </div>`;
                });
            }
            document.getElementById('quarterFinals').innerHTML = qfHtml;

            // Semi Finals
            const semiFinalsCollection = collection(db, "knockoutMatches", "semi_finals", "matches");
            const sfSnapshot = await getDocs(semiFinalsCollection);
            let sfHtml = "<h3>Semi Finals</h3>";
            if (sfSnapshot.empty) {
                sfHtml += "<p>No Semi Final matches scheduled or played yet.</p>";
            } else {
                sfSnapshot.forEach(doc => {
                    const match = doc.data();
                    const teamA = match.teamA || "TBD";
                    const teamB = match.teamB || "TBD";
                    const scoreA = match.scoreA !== undefined ? match.scoreA : '';
                    const scoreB = match.scoreB !== undefined ? match.scoreB : '';
                    const venue = match.venue || "TBD";
                    const time = match.time || "TBD";

                    sfHtml += `<div class="match-info">
                                    <p class="teams">${teamA} vs ${teamB}</p>
                                    <p class="score">Score: ${scoreA} - ${scoreB}</p>
                                    <p class="venue-time">Venue: ${venue}, Time: ${time}</p>
                                </div>`;
                });
            }
            document.getElementById('semiFinals').innerHTML = sfHtml;

            // Final Match
            const finalCollection = collection(db, "knockoutMatches", "final", "matches");
            const finalSnapshot = await getDocs(finalCollection);
            let finalHtml = "<h3>Final</h3>";
            if (finalSnapshot.empty) {
                finalHtml += "<p>No Final match scheduled or played yet.</p>";
            } else {
                finalSnapshot.forEach(doc => {
                    const match = doc.data();
                    const teamA = match.teamA || "TBD";
                    const teamB = match.teamB || "TBD";
                    const scoreA = match.scoreA !== undefined ? match.scoreA : '';
                    const scoreB = match.scoreB !== undefined ? match.scoreB : '';
                    const venue = match.venue || "TBD";
                    const time = match.time || "TBD";

                    finalHtml += `<div class="match-info">
                                    <p class="teams">${teamA} vs ${teamB}</p>
                                    <p class="score">Score: ${scoreA} - ${scoreB}</p>
                                    <p class="venue-time">Venue: ${venue}, Time: ${time}</p>
                                </div>`;
                });
            }
            document.getElementById('finalMatch').innerHTML = finalHtml;

        } catch (error) {
            console.error("Error fetching Next Stage data: ", error);
            document.getElementById('quarterFinals').innerHTML = "<p>Error loading Quarter Final data.</p>";
            document.getElementById('semiFinals').innerHTML = "<p>Error loading Semi Final data.</p>";
            document.getElementById('finalMatch').innerHTML = "<p>Error loading Final data.</p>";
        }
    }

    /**
     * Fetches and displays data for the Group Stage (tables and match matrix).
     * Assumes match results are stored under 'matchResults' collection,
     * with each group as a document (e.g., 'matchResults/A').
     * Each group document has 'venue', 'time', and a 'matches' object.
     * Also fetches team names from 'teams' collection to build the matrix.
     */
    async function fetchGroupStageData() {
        try {
            let groupTablesHtml = "<h3>Group Stage Tables</h3>";

            // Fetch all teams to get group members
            const teamsSnapshot = await getDocs(collection(db, "teams"));
            const teamsByGroup = {};
            teamsSnapshot.forEach(doc => {
                const data = doc.data();
                const group = data.group;
                const teamName = data.teamName;
                if (group && teamName) {
                    if (!teamsByGroup[group]) teamsByGroup[group] = [];
                    teamsByGroup[group].push(teamName);
                }
            });

            // Process standings for each group
            for (const group of groups) {
                const groupDocRef = doc(db, "matchResults", group);
                const groupDocSnap = await getDoc(groupDocRef);

                const groupTeams = teamsByGroup[group] || [];
                groupTeams.sort(); // Sort teams alphabetically for consistent order

                // Initialize standings for current group
                const standings = {};
                groupTeams.forEach(teamName => {
                    standings[teamName] = {
                        teamName: teamName, // Pastikan teamName ada di sini
                        played: 0,
                        wins: 0,
                        losses: 0,
                        draws: 0,
                        points: 0,
                        scoreFor: 0,
                        scoreAgainst: 0,
                        difference: 0
                    };
                });

                if (groupDocSnap.exists() && groupDocSnap.data().matches) {
                    const matches = groupDocSnap.data().matches;
                    for (const matchKey in matches) {
                        if (matches.hasOwnProperty(matchKey)) {
                            const scoreStr = matches[matchKey];
                            const parts = matchKey.replace(/_/g, ' ').split(' vs ');
                            let teamA = parts[0] ? parts[0].trim() : null;
                            let teamB = parts[1] ? parts[1].trim() : null;

                            // Pastikan kedua tim ada dan diinisialisasi dalam klasemen untuk grup ini
                            if (!teamA || !teamB || !standings[teamA] || !standings[teamB]) {
                                console.warn(`Skipping match ${matchKey} in group ${group}: Team data not found or invalid.`);
                                continue;
                            }

                            const scoreParts = scoreStr.split('-');
                            if (scoreParts.length === 2) {
                                let scoreA = parseInt(scoreParts[0]);
                                let scoreB = parseInt(scoreParts[1]);

                                if (!isNaN(scoreA) && !isNaN(scoreB)) {
                                    // Update played matches
                                    standings[teamA].played++;
                                    standings[teamB].played++;

                                    // Update scores
                                    standings[teamA].scoreFor += scoreA;
                                    standings[teamA].scoreAgainst += scoreB;
                                    standings[teamB].scoreFor += scoreB;
                                    standings[teamB].scoreAgainst += scoreA;

                                    // Update wins, losses, draws, and points
                                    if (scoreA > scoreB) {
                                        standings[teamA].wins++;
                                        standings[teamB].losses++;
                                        standings[teamA].points += 3;
                                    } else if (scoreB > scoreA) {
                                        standings[teamB].wins++;
                                        standings[teamA].losses++;
                                        standings[teamB].points += 3;
                                    } else { // Draw
                                        standings[teamA].draws++;
                                        standings[teamB].draws++;
                                        standings[teamA].points += 1;
                                        standings[teamB].points += 1;
                                    }
                                }
                            }
                        }
                    }
                }

                // Hitung perbedaan dan siapkan untuk penyortiran
                let sortedStandings = Object.values(standings).map(teamStat => {
                    teamStat.difference = teamStat.scoreFor - teamStat.scoreAgainst;
                    return teamStat;
                }).sort((a, b) => {
                    // Sort by Points (descending)
                    if (b.points !== a.points) return b.points - a.points;
                    // Then by Difference (descending)
                    if (b.difference !== a.difference) return b.difference - a.difference;
                    // Then by Score+ (descending)
                    if (b.scoreFor !== a.scoreFor) return b.scoreFor - a.scoreFor;
                    // Finally by Team Name (alphabetical ascending)
                    return a.teamName.localeCompare(b.teamName); // Sekarang 'a.teamName' seharusnya ada
                });


                // Generate HTML for Group Table
                if (sortedStandings.length > 0 || groupTeams.length > 0) { // Render table even if no matches played
                    groupTablesHtml += `<h4>Group ${group} Standings</h4>`;
                    groupTablesHtml += `<table class="group-standings-table">
                                        <thead>
                                            <tr>
                                                <th>Team</th>
                                                <th>Played</th>
                                                <th>Win</th>
                                                <th>Loss</th>
                                                <th>Draw</th>
                                                <th>Points</th>
                                                <th>Score+</th>
                                                <th>Score-</th>
                                                <th>Diff</th>
                                            </tr>
                                        </thead>
                                        <tbody>`;
                    if (sortedStandings.length > 0) {
                        sortedStandings.forEach(team => {
                            groupTablesHtml += `<tr>
                                                    <td>${team.teamName || 'N/A'}</td>
                                                    <td>${team.played}</td>
                                                    <td>${team.wins}</td>
                                                    <td>${team.losses}</td>
                                                    <td>${team.draws}</td>
                                                    <td>${team.points}</td>
                                                    <td>${team.scoreFor}</td>
                                                    <td>${team.scoreAgainst}</td>
                                                    <td>${team.difference}</td>
                                                </tr>`;
                        });
                    } else if (groupTeams.length > 0) {
                        // If teams exist but no matches, display them with 0s
                         groupTeams.forEach(teamName => {
                             groupTablesHtml += `<tr>
                                                     <td>${teamName || 'N/A'}</td>
                                                     <td>0</td>
                                                     <td>0</td>
                                                     <td>0</td>
                                                     <td>0</td>
                                                     <td>0</td>
                                                     <td>0</td>
                                                     <td>0</td>
                                                     <td>0</td>
                                                 </tr>`;
                         });
                    } else {
                         groupTablesHtml += `<tr><td colspan="9">No teams registered for this group.</td></tr>`;
                    }
                    groupTablesHtml += `</tbody></table>`;
                } else {
                    groupTablesHtml += `<h4>Group ${group} Standings</h4><p>No teams registered for Group ${group}.</p>`;
                }
            }
            document.getElementById('groupTables').innerHTML = groupTablesHtml;


            // --- Match Matrix ---
            let matchMatrixHtml = "<h3>Group Stage Match Matrix</h3>";
            for (const group of groups) {
                const groupDocRef = doc(db, "matchResults", group);
                const groupDocSnap = await getDoc(groupDocRef);
                
                const groupTeams = teamsByGroup[group] || [];
                groupTeams.sort();

                matchMatrixHtml += `<h4>Group ${group}</h4>`;

                // Always render the table structure
                if (groupTeams.length > 0) {
                    const venue = groupDocSnap.exists() ? (groupDocSnap.data().venue || 'N/A') : 'N/A';
                    const time = groupDocSnap.exists() ? (groupDocSnap.data().time || 'N/A') : 'N/A';
                    matchMatrixHtml += `<div class="venue-time">Venue: ${venue}, Time: ${time}</div>`;

                    matchMatrixHtml += `<table class="match-matrix-table">
                                        <thead>
                                            <tr>
                                                <th></th>`; // Top-left empty cell
                    groupTeams.forEach(team => {
                        matchMatrixHtml += `<th>${team}</th>`;
                    });
                    matchMatrixHtml += `</tr></thead><tbody>`;

                    groupTeams.forEach(rowTeam => {
                        matchMatrixHtml += `<tr><th>${rowTeam}</th>`;
                        groupTeams.forEach(colTeam => {
                            if (rowTeam === colTeam) {
                                matchMatrixHtml += `<td class="empty-cell"></td>`; // Empty diagonal cell
                            } else {
                                let score = "-"; // Default to '-'
                                if (groupDocSnap.exists() && groupDocSnap.data().matches) {
                                    const matches = groupDocSnap.data().matches;
                                    const key1 = `${rowTeam}_vs_${colTeam}`;
                                    const key2 = `${colTeam}_vs_${rowTeam}`;

                                    if (matches[key1]) {
                                        score = matches[key1];
                                    } else if (matches[key2]) {
                                        const parts = matches[key2].split('-');
                                        if (parts.length === 2) {
                                            score = `${parts[1]}-${parts[0]}`; // Reverse score for display
                                        } else {
                                            score = matches[key2];
                                        }
                                    }
                                }
                                matchMatrixHtml += `<td class="score-cell">${score}</td>`;
                            }
                        });
                        matchMatrixHtml += `</tr>`;
                    });
                    matchMatrixHtml += `</tbody></table>`;
                } else {
                    matchMatrixHtml += `<p>No teams registered for Group ${group}.</p>`;
                }
            }
            document.getElementById('matchMatrix').innerHTML = matchMatrixHtml;

        } catch (error) {
            console.error("Error fetching Group Stage data: ", error);
            document.getElementById('groupTables').innerHTML = "<p>Error loading group tables data.</p>";
            document.getElementById('matchMatrix').innerHTML = "<p>Error loading match matrix data.</p>";
        }
    }

    // Call fetch functions when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        // Initial setup for Group Stage as active tab
        window.switchTab('groupStage'); 

        console.log("Fetching Next Stage data...");
        fetchNextStageData(); 

        console.log("Fetching Group Stage data...");
        fetchGroupStageData();
    });
  </script>
</body>
</html>
