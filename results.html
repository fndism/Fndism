<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Petanque Results</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f9fa;
      padding: 20px;
      min-height: 100vh; /* Ensure body takes full viewport height for footer positioning */
      display: flex;
      flex-direction: column;
    }
    h1 {
      text-align: center;
      color: #343a40;
      margin-bottom: 30px;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center; /* Center the tabs */
    }
    .tab {
      padding: 10px 20px;
      background: #007bff;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold; /* Make tab text bolder */
      transition: background-color 0.3s ease; /* Smooth transition for hover */
    }
    .tab:hover {
      background: #0056b3; /* Darker blue on hover */
    }
    .tab.active {
      background: #0056b3;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add shadow to active tab */
    }
    .tab-content {
      display: none;
      padding: 15px; /* Add some padding to content */
      background: #fff; /* White background for content */
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      flex-grow: 1; /* Allow content to grow and push footer down */
    }
    .tab-content.active {
      display: block;
    }
    h2 {
      color: #007bff;
      border-bottom: 2px solid #007bff;
      padding-bottom: 5px;
      margin-top: 25px;
      margin-bottom: 15px;
    }
    h3 { /* Style for sub-sections like "Group Stage Tables" */
        color: #343a40;
        font-size: 1.5em;
        margin-top: 20px;
        margin-bottom: 15px;
        text-align: center;
    }
    h4 { /* Style for individual group headers */
        color: #0056b3;
        font-size: 1.2em;
        margin-top: 15px;
        margin-bottom: 10px;
        text-align: left;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* Subtle shadow for tables */
    }
    th, td {
      border: 1px solid #ccc;
      text-align: center;
      padding: 10px; /* Increased padding */
    }
    th {
      background: #e9ecef;
      color: #343a40;
      font-weight: bold;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2; /* Zebra striping for tables */
    }
    .match-info, .knockout {
      background: #fff;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .match-info p {
      margin: 5px 0; /* Spacing for match info */
    }
    .match-info .score {
      font-weight: bold;
      color: #dc3545; /* Red for scores */
    }
    .match-info .teams {
      font-size: 1.1em;
      font-weight: bold;
    }
    .venue-time {
      font-style: italic;
      margin-top: 5px;
      color: #6c757d;
      font-size: 0.9em;
    }
    /* Specific styling for the Match Details table */
    .match-matrix-table td {
        background-color: #fff; /* Ensure all cells have a uniform white background */
    }
    .match-matrix-table td.empty-cell {
        background-color: #eee; /* Keep distinct background for empty cells */
    }
    .match-matrix-table td.score-cell {
        font-weight: bold;
        color: #0056b3;
    }

    /* --- Knockout Bracket Styling --- */
    .tournament-bracket {
        display: grid;
        grid-template-columns: repeat(3, 1fr); /* QF, SF, Final */
        gap: 10px;
        max-width: 900px; /* Max width for the bracket */
        margin: 20px auto;
        padding: 20px;
        background: #fdfdfd;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        text-align: center;
    }
    .bracket-stage {
        display: flex;
        flex-direction: column;
        justify-content: space-around; /* Distribute matches evenly by default */
        padding: 10px 0;
    }
    .bracket-stage.quarter-finals-stage {
        grid-column: 1 / 2; /* First column */
    }
    .bracket-stage.semi-finals-stage {
        grid-column: 2 / 3; /* Second column */
        justify-content: center; /* ALIGNMENT FIX: Center content vertically for semi-finals */
    }
    .bracket-stage.final-stage {
        grid-column: 3 / 4; /* Third column */
        justify-content: center; /* Center the final match */
    }

    .bracket-match {
        background: #e9f5ff; /* Light blue for match boxes */
        border: 1px solid #cceeff;
        border-radius: 8px;
        padding: 10px;
        margin: 10px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        position: relative; /* For connecting lines */
        min-height: 80px; /* Ensure consistent height */
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .bracket-match .teams {
        font-weight: bold;
        color: #333;
        font-size: 0.95em;
    }
    .bracket-match .score {
        color: #dc3545;
        font-weight: bold;
        font-size: 0.9em;
        margin-top: 5px;
    }
    .bracket-match .venue-time {
        font-size: 0.8em;
        color: #666;
        margin-top: 5px;
    }

    /* Connecting Lines - simplified for display */
    .bracket-match::after, .bracket-match::before {
        content: '';
        position: absolute;
        background: #999;
        z-index: 1;
    }
    .bracket-stage.quarter-finals-stage .bracket-match::after {
        top: 50%;
        right: -5px; /* Connects to the next stage container boundary */
        width: 5px;
        height: 1px;
        transform: translateY(-50%);
    }
    .bracket-stage.semi-finals-stage .bracket-match::after {
        top: 50%;
        right: -5px;
        width: 5px;
        height: 1px;
        transform: translateY(-50%);
    }

    /* Vertical connector for SF to Final */
    .bracket-stage.semi-finals-stage .bracket-match:first-child::before {
        content: '';
        position: absolute;
        bottom: -15px; /* Adjust based on match spacing */
        left: 50%;
        width: 1px;
        height: 30px; /* Length of vertical line */
        background: #999;
        transform: translateX(-50%);
        z-index: 0;
    }
    
    /* Hide lines for placeholder/empty messages */
    .bracket-match.no-data-message::after,
    .bracket-match.no-data-message::before {
        display: none;
    }

    @media (max-width: 768px) {
        .tournament-bracket {
            grid-template-columns: 1fr; /* Stack columns on smaller screens */
        }
        .bracket-stage {
            border-bottom: 1px solid #eee; /* Separate stages */
            margin-bottom: 10px;
        }
        .bracket-stage:last-child {
            border-bottom: none;
        }
        .bracket-match::after,
        .bracket-match::before,
        .semi-finals-stage .bracket-match::before {
            display: none; /* Hide lines on mobile */
        }
    }

    /* Footer styling */
    .footer {
        margin-top: auto; /* Push footer to the bottom */
        padding-top: 20px;
        text-align: center;
        font-size: 0.9em;
        color: #777;
    }

    .download-button-container {
        text-align: center;
        margin-top: 20px;
        margin-bottom: 20px;
    }

    .download-pdf-button {
        background-color: #dc3545; /* Red for PDF */
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
    }
    .download-pdf-button:hover {
        background-color: #c82333; /* Darker red on hover */
    }

    .fixtures-table-container {
        margin-bottom: 30px;
    }
    .fixtures-table-container table {
        margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>SMZ18201: Petanque Match Results</h1>

  <div class="tabs">
    <div class="tab active" onclick="window.switchTab('groupStage')">Group Stage</div>
    <div class="tab" onclick="window.switchTab('nextStage')">Next Stage</div>
    <div class="tab" onclick="window.switchTab('fixtures')">Fixtures</div>
    <div class="tab" onclick="window.location.href='index.html'">⬅ Homepage</div>
  </div>

  <div class="download-button-container">
    <button onclick="window.downloadResultsPdf()" class="download-pdf-button">
      ⬇ Download Results as PDF
    </button>
  </div>

  <!-- Group Stage Content - now active by default -->
  <div id="groupStage" class="tab-content active">
    <h2 id="groupStageTablesHeader">Group Stage Tables</h2>
    <div id="groupTables">Loading group tables...</div>
    <h2 id="groupMatchDetailsHeader">Match Details</h2>
    <div id="matchMatrix">Loading match details...</div>
  </div>

  <!-- Next Stage Content - now inactive by default -->
  <div id="nextStage" class="tab-content">
    <!-- Tournament Bracket Container -->
    <div class="tournament-bracket">
        <div class="bracket-stage quarter-finals-stage">
            <h2>Quarter Final</h2>
            <div id="quarterFinals">Loading Quarter Final matches...</div>
        </div>

        <div class="bracket-stage semi-finals-stage">
            <h2>Semi Final</h2>
            <div id="semiFinals">Loading Semi Final matches...</div>
        </div>

        <div class="bracket-stage final-stage">
            <h2>Final</h2>
            <div id="finalMatch">Loading Final match...</div>
        </div>
    </div>
  </div>

  <!-- New Fixtures Content Tab -->
  <div id="fixtures" class="tab-content">
    <h2>All Scheduled Matches (Fixtures)</h2>
    <div class="download-button-container">
        <button onclick="window.downloadFixturesPdf()" class="download-pdf-button">
            ⬇ Download Fixtures as PDF
        </button>
    </div>
    <div id="fixturesContent">Loading fixtures...</div>
  </div>

  <div class="footer">
    <p>&copy; 2025 Fndism. All rights reserved.</p>
  </div>

  <!-- jsPDF and jspdf-autotable CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

  <script type="module">
    // Firebase configuration and initialization
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, getDoc } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDpS-kqwQDgdqiVK2kwXGB9a3B7WeJI_Iw",
      authDomain: "unimap-petanque.firebaseapp.com",
      projectId: "unimap-petanque",
      storageBucket: "unimap-petanque.appspot.com",
      messagingSenderId: "578920021890",
      appId: "1:578920021890:web:987ed2de28e7b0353c999b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Make db, collection, getDocs, doc, getDoc globally accessible
    window.db = db;
    window.collection = collection;
    window.getDocs = getDocs;
    window.doc = doc;
    window.getDoc = getDoc;


    // Define groups array and venues
    window.groups = ["A", "B", "C", "D", "E", "F"];
    const venues = {
        "A": "PADANG 1",
        "B": "PADANG 2",
        "C": "PADANG 3",
        "D": "PADANG 4",
        "E": "PADANG 5",
        "F": "PADANG 6"
    };

    // Make switchTab globally accessible
    window.switchTab = function(tabId) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      // Find the tab element by its onclick attribute to apply active class
      const targetTabElement = document.querySelector(`.tab[onclick*="switchTab('${tabId}')"]`);
      // Special handling for Homepage tab as it uses window.location.href
      if (tabId === 'homepage') {
          document.querySelector(`.tab[onclick*="window.location.href='index.html'"]`).classList.add('active');
      } else if (targetTabElement) {
          targetTabElement.classList.add('active');
      }
      document.getElementById(tabId).classList.add('active');

      // Reload content when switching tabs
      if (tabId === 'groupStage') {
          window.fetchGroupStageData();
      } else if (tabId === 'nextStage') {
          window.fetchNextStageData();
      } else if (tabId === 'fixtures') {
          window.fetchAllFixtures();
      }
    }

    // Helper function to compare team standings for sorting.
    function compareTeamStandings(a, b) {
        if (b.points !== a.points) return b.points - a.points;
        if (b.difference !== a.difference) return b.difference - a.difference;
        if (b.scoreFor !== a.scoreFor) return b.scoreFor - a.scoreFor; // Sort by Score For
        return a.teamName.localeCompare(b.teamName); // Then alphabetically by name
    }

    // Formats time from hour and minute to HH:MM AM/PM
    function formatTime(hour, minute) {
        const period = hour >= 12 ? 'PM' : 'AM';
        const displayHour = hour % 12 === 0 ? 12 : hour % 12;
        const displayMinute = minute < 10 ? '0' + minute : minute;
        return `${displayHour}:${displayMinute}${period}`;
    }

    // Calculates match time based on index and interval
    function getMatchTime(matchIndex, baseHour = 14, baseMinute = 30, intervalMinutes = 30) {
        let totalMinutes = baseHour * 60 + baseMinute + (matchIndex * intervalMinutes);
        let hour = Math.floor(totalMinutes / 60);
        let minute = totalMinutes % 60;
        return formatTime(hour, minute);
    }

    /**
     * Generates a list of generic team names for a given group letter.
     * E.g., 'A' -> ['Team A1', 'Team A2', 'Team A3', 'Team A4', 'Team A5']
     * These are for fixed fixture generation, not from database.
     * @param {string} groupLetter - The group identifier (e.g., 'A', 'B').
     * @param {number} numTeams - The number of generic teams to generate for this group (default to 5).
     * @returns {string[]} An array of generic team names.
     */
    function getGroupFixtureTeams(groupLetter, numTeams = 5) { // Changed default numTeams to 5
        const teams = [];
        for (let i = 1; i <= numTeams; i++) {
            teams.push(`Team ${groupLetter}${i}`);
        }
        return teams;
    }


    /**
     * Generates round-robin fixtures for a given list of teams using the circle method.
     * Ensures each team plays every other team once, and distributes matches across rounds.
     * This method aims to balance play for each team across rounds.
     * @param {string[]} teams - Array of team names.
     * @returns {string[]} Array of match strings (e.g., "TeamA vs TeamB") in round order.
     */
    function generateRoundRobinFixtures(teams) {
        const numOriginalTeams = teams.length;
        if (numOriginalTeams < 2) return [];

        let allTeams = [...teams].sort(); // Sort teams alphabetically for consistent initial order

        // If odd number of teams, add a "dummy" team for scheduling.
        const hasDummy = numOriginalTeams % 2 !== 0;
        if (hasDummy) {
            allTeams.push("BYE_TEAM");
        }

        const N = allTeams.length; // N is now always an even number
        const numRounds = N - 1; // Total rounds in a round-robin
        const matchesPerRound = N / 2; // Number of matches played concurrently in each round
        
        const scheduledMatches = [];

        for (let round = 0; round < numRounds; round++) {
            const currentRoundMatches = [];
            // In the circle method, the first team (allTeams[0]) stays fixed.
            for (let i = 0; i < matchesPerRound; i++) {
                const team1 = allTeams[i];
                const team2 = allTeams[N - 1 - i];

                // Only add real matches; skip any match involving the "BYE_TEAM"
                if (team1 !== "BYE_TEAM" && team2 !== "BYE_TEAM") {
                    // Store in canonical (alphabetical) order for internal consistency
                    currentRoundMatches.push(team1 < team2 ? `${team1} vs ${team2}` : `${team2} vs ${team1}`);
                }
            }
            // Add the matches for the current round to the overall schedule.
            // Sort matches within each round for consistent output in the display.
            currentRoundMatches.sort(); 
            scheduledMatches.push(...currentRoundMatches);

            // Perform the rotation for the next round.
            // Teams from index 1 to N-1 rotate. The last team moves to position 1.
            if (N > 1) { // Ensure there are teams to rotate
                const lastTeamInRotatingGroup = allTeams.pop(); // Remove the very last team
                allTeams.splice(1, 0, lastTeamInRotatingGroup); // Insert it at index 1 (after the fixed team)
            }
        }
        return scheduledMatches;
    }

    /**
     * Orders the generated round-robin matches to prioritize the user's specific sequence
     * for the first few matches, then appends the remaining unique matches.
     * This function now tries to minimize consecutive plays *after* the initial fixed ones.
     * @param {string[]} allGeneratedMatches - All unique round-robin matches (canonical order).
     * @param {string[]} genericTeams - The sorted list of generic team names for the group (e.g., ['Team A1', 'Team A2', ...]).
     * @returns {string[]} An array of match strings in the desired display order, limited to 10.
     */
    function orderFixturesForUserDisplay(allGeneratedMatches, genericTeams) {
        const orderedList = [];
        const usedMatchesCanonical = new Set(); // Stores canonical forms to avoid duplicates

        const getCanonical = (t1, t2) => t1 < t2 ? `${t1} vs ${t2}` : `${t2} vs ${t1}`;

        // 1. Add user's specific priority matches
        const team1 = genericTeams[0]; // Corresponds to A1
        const team2 = genericTeams[1]; // Corresponds to A2
        const team3 = genericTeams[2]; // Corresponds to A3
        const team4 = genericTeams[3]; // Corresponds to A4
        const team5 = genericTeams[4]; // Corresponds to A5

        const specificMatches = [];
        if (team1 && team2) specificMatches.push({ display: `${team1} vs ${team2}`, canonical: getCanonical(team1, team2) });
        if (team3 && team4) specificMatches.push({ display: `${team3} vs ${team4}`, canonical: getCanonical(team3, team4) });
        if (team5 && team1) specificMatches.push({ display: `${team5} vs ${team1}`, canonical: getCanonical(team5, team1) });

        for (const sm of specificMatches) {
            if (!usedMatchesCanonical.has(sm.canonical)) {
                orderedList.push(sm.display);
                usedMatchesCanonical.add(sm.canonical);
            }
        }

        // 2. Prepare remaining matches and schedule greedily
        let remainingMatchesCandidates = allGeneratedMatches
            .filter(match => !usedMatchesCanonical.has(match))
            .map(match => ({
                display: match, // For display, can keep canonical here or re-order if specific request
                canonical: match,
                teams: match.split(' vs ').map(t => t.trim())
            }));

        // Sort remaining matches to ensure consistent filling if no other criteria apply
        // This is important for deterministic output, even if it doesn't solve 'semput' for *all* cases.
        remainingMatchesCandidates.sort((a, b) => a.canonical.localeCompare(b.canonical));

        let lastPlayedTeams = [];
        if (orderedList.length > 0) {
            lastPlayedTeams = orderedList[orderedList.length - 1].split(' vs ').map(t => t.trim());
        }

        while (orderedList.length < 10 && remainingMatchesCandidates.length > 0) {
            let bestCandidateIndex = -1;
            let minOverlap = 2; // 0: no overlap, 1: one team overlaps, 2: both teams overlap (or no suitable)

            // Find a match with minimal overlap with lastPlayedTeams
            // Prioritize matches that don't involve teams from the last played match
            for (let i = 0; i < remainingMatchesCandidates.length; i++) {
                const candidate = remainingMatchesCandidates[i];
                const overlapCount = candidate.teams.filter(team => lastPlayedTeams.includes(team)).length;

                if (overlapCount < minOverlap) {
                    minOverlap = overlapCount;
                    bestCandidateIndex = i;
                    if (minOverlap === 0) break; // Found perfect match (no overlap), no need to check further
                }
            }

            if (bestCandidateIndex !== -1) {
                const chosenMatch = remainingMatchesCandidates.splice(bestCandidateIndex, 1)[0];
                orderedList.push(chosenMatch.display);
                usedMatchesCanonical.add(chosenMatch.canonical);
                lastPlayedTeams = chosenMatch.teams; // Update last played teams
            } else {
                // This scenario should ideally not be reached if all unique matches are available
                // and there are enough slots. But as a fallback, break to prevent infinite loop.
                break;
            }
        }
        
        // Ensure final list is exactly 10, or whatever was filled if less than 10 matches are possible
        return orderedList.slice(0, 10);
    }


    // Fetches and processes all group stage data (This function still uses actual teams from DB)
    window.getGroupStageData = async function() {
        const result = {
            standingsByGroup: {},
            matchesByGroup: {},
            teamsByGroup: {}
        };

        const teamsSnapshot = await window.getDocs(window.collection(window.db, "teams"));
        teamsSnapshot.forEach(documentSnapshot => {
            const data = documentSnapshot.data();
            const group = data.group;
            const teamName = data.teamName;
            if (group && teamName) {
                if (!result.teamsByGroup[group]) result.teamsByGroup[group] = [];
                result.teamsByGroup[group].push(teamName);
            }
        });

        for (const group of window.groups) {
            const groupDocRef = window.doc(window.db, "matchResults", group);
            const groupDocSnap = await window.getDoc(groupDocRef);

            const groupTeams = result.teamsByGroup[group] || [];
            groupTeams.sort();

            const standings = {};
            groupTeams.forEach(teamName => {
                standings[teamName] = {
                    teamName: teamName,
                    played: 0, wins: 0, losses: 0, draws: 0,
                    points: 0, scoreFor: 0, scoreAgainst: 0, difference: 0
                };
            });

            if (groupDocSnap.exists() && groupDocSnap.data().matches) {
                const matches = groupDocSnap.data().matches;
                result.matchesByGroup[group] = matches;
                
                for (const matchKey in matches) {
                    if (matches.hasOwnProperty(matchKey)) {
                        const scoreStr = matches[matchKey];
                        const parts = matchKey.replace(/_/g, ' ').split(' vs ');
                        let teamA = parts[0] ? parts[0].trim() : null;
                        let teamB = parts[1] ? parts[1].trim() : null;

                        if (!teamA || !teamB || !standings[teamA] || !standings[teamB]) {
                            console.warn(`Skipping match ${matchKey} in group ${group}: Team data not found or invalid.`);
                            continue;
                        }

                        const scoreParts = scoreStr.split('-');
                        if (scoreParts.length === 2) {
                            let scoreA = parseInt(scoreParts[0]);
                            let scoreB = parseInt(scoreParts[1]);

                            if (!isNaN(scoreA) && !isNaN(scoreB)) {
                                standings[teamA].played++; standings[teamB].played++;
                                standings[teamA].scoreFor += scoreA; standings[teamA].scoreAgainst += scoreB;
                                standings[teamB].scoreFor += scoreB; standings[teamB].scoreAgainst += scoreA;

                                if (scoreA > scoreB) {
                                    standings[teamA].wins++; standings[teamB].losses++; standings[teamA].points += 3;
                                } else if (scoreB > scoreA) {
                                    standings[teamB].wins++; standings[teamA].losses++; standings[teamB].points += 3;
                                } else {
                                    standings[teamA].draws++; standings[teamB].draws++;
                                    standings[teamA].points += 1; standings[teamB].points += 1;
                                }
                            }
                        }
                    }
                }
            }

            let sortedStandings = Object.values(standings).map(teamStat => {
                teamStat.difference = teamStat.scoreFor - teamStat.scoreAgainst;
                return teamStat;
            }).sort(compareTeamStandings);

            result.standingsByGroup[group] = sortedStandings;
        }
        return result;
    }

    // Fetches and displays data for the Next Stage (Quarter, Semi, Final).
    window.fetchNextStageData = async function() {
        try {
            const { standingsByGroup } = await window.getGroupStageData();

            let groupWinners = [];
            let allRunnersUp = [];

            for (const group of window.groups) {
                const groupStandings = standingsByGroup[group];
                // Ensure there's a winner before pushing
                if (groupStandings && groupStandings.length >= 1 && groupStandings[0].teamName !== "TBD") {
                    groupWinners.push(groupStandings[0]); // Winner is rank 0
                }
                // Ensure there's a runner-up before pushing
                if (groupStandings && groupStandings.length >= 2 && groupStandings[1].teamName !== "TBD") {
                    allRunnersUp.push(groupStandings[1]); // Runner-up is rank 1
                }
            }

            allRunnersUp.sort(compareTeamStandings);
            const top2RunnersUp = allRunnersUp.slice(0, 2); // Get the best 2 runners-up

            let qualifiers = [...groupWinners, ...top2RunnersUp];
            qualifiers.sort(compareTeamStandings); // Sort all 8 qualifiers (6 winners + 2 runners-up)

            // Fetch actual knockout match results
            const knockoutMatchesData = {
                quarter_finals: [],
                semi_finals: [],
                final: []
            };

            // Correctly access subcollections for knockout matches
            const qfRef = window.collection(window.doc(window.db, "knockoutMatches", "quarter_finals"), "matches");
            const qfSnapshot = await window.getDocs(qfRef);
            qfSnapshot.forEach(doc => knockoutMatchesData.quarter_finals.push({ id: doc.id, ...doc.data() }));

            const sfRef = window.collection(window.doc(window.db, "knockoutMatches", "semi_finals"), "matches");
            const sfSnapshot = await window.getDocs(sfRef);
            sfSnapshot.forEach(doc => knockoutMatchesData.semi_finals.push({ id: doc.id, ...doc.data() }));
            
            const finalRef = window.collection(window.doc(window.db, "knockoutMatches", "final"), "matches");
            const finalSnapshot = await window.getDocs(finalRef);
            finalSnapshot.forEach(doc => knockoutMatchesData.final.push({ id: doc.id, ...doc.data() }));


            // --- Quarter Finals ---
            let qfHtml = "";
            const qfLabels = ["QF1", "QF2", "QF3", "QF4"];
            let qfWinners = {}; // To store QF winners for SF matchups

            // Define QF pairings based on sorted qualifiers.
            const qfPotentialPairings = [
                { teamA: qualifiers[0] || null, teamB: qualifiers[7] || null }, // Rank 1 vs Rank 8
                { teamA: qualifiers[3] || null, teamB: qualifiers[4] || null }, // Rank 4 vs Rank 5
                { teamA: qualifiers[1] || null, teamB: qualifiers[6] || null }, // Rank 2 vs Rank 7
                { teamA: qualifiers[2] || null, teamB: qualifiers[5] || null }  // Rank 3 vs Rank 6
            ];
            
            qfPotentialPairings.forEach((pairing, index) => {
                const label = qfLabels[index];
                const firebaseMatchId = label; // Use the label as the Firestore document ID

                let displayTeamA = "TBD";
                let displayTeamB = "TBD";
                let score = "- (No Data)";
                let venue = "TBD";
                let time = "TBD";
                let isNoData = true; // Controls the 'no-data-message' class
                
                // Try to find existing match data for this specific QF label (e.g., QF1)
                const matchData = knockoutMatchesData.quarter_finals.find(m => m.id === firebaseMatchId);

                if (matchData && matchData.teamA && matchData.teamB) { // If match data exists and has valid team names
                    displayTeamA = matchData.teamA;
                    displayTeamB = matchData.teamB;
                    if (!isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                        score = `${matchData.scoreA} - ${matchData.scoreB}`;
                    }
                    venue = matchData.venue || "TBD";
                    time = matchData.time || "TBD";
                    isNoData = false;
                } else {
                    // If no data, but potential teams are known, show them
                    if (pairing.teamA && pairing.teamA.teamName && pairing.teamA.teamName !== "TBD" &&
                        pairing.teamB && pairing.teamB.teamName && pairing.teamB.teamName !== "TBD") {
                        displayTeamA = pairing.teamA.teamName;
                        displayTeamB = pairing.teamB.teamName;
                    }
                }
                
                // Determine winner for SF pairing based on saved data, or TBD if not available
                let winner = "TBD";
                if (matchData && !isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                    if (matchData.scoreA > matchData.scoreB) {
                        winner = matchData.teamA;
                    } else if (matchData.scoreB > matchData.scoreA) {
                        winner = matchData.teamB;
                    } else {
                        winner = "DRAW"; // Should not happen in Petanque
                    }
                }
                qfWinners[label] = winner; // Store the winner for SF pairing

                qfHtml += `<div class="bracket-match ${isNoData ? 'no-data-message' : ''}">
                                <p class="teams">${label}: ${displayTeamA} vs ${displayTeamB}</p>
                                <p class="score">Score: ${score}</p>
                                <p class="venue-time">Venue: ${venue}, Time: ${time}</p>
                            </div>`;
            });
            
            // Display a message if not enough qualifiers for QF
            if (qualifiers.length < 8) {
                qfHtml += `<div class="bracket-match no-data-message" style="margin-top: 10px;">
                                <p>Only ${qualifiers.length}/8 teams qualified so far. Finish group stage to generate Quarter Final matches.</p>
                            </div>`;
            }
            document.getElementById('quarterFinals').innerHTML = qfHtml;

            // --- Semi Finals ---
            let sfHtml = "";
            const sfLabels = ["SF1", "SF2"];
            let sfWinners = {}; // To store SF winners for Final matchup

            // Determine SF pairings based on QF winners (actual determined winners or "TBD")
            const sfPotentialPairings = [
                { teamA: qfWinners["QF1"], teamB: qfWinners["QF2"] },
                { teamA: qfWinners["QF3"], teamB: qfWinners["QF4"] }
            ];

            for (let i = 0; i < 2; i++) {
                const label = sfLabels[i];
                const firebaseMatchId = label; // Use the label as the Firestore document ID

                let displayTeamA = "TBD";
                let displayTeamB = "TBD";
                let score = "- (No Data)";
                let venue = "TBD";
                let time = "TBD";
                let isNoData = true;    
                
                const matchData = knockoutMatchesData.semi_finals.find(m => m.id === firebaseMatchId);
                
                if (matchData && matchData.teamA && matchData.teamB) { // If match data exists and has valid team names
                    displayTeamA = matchData.teamA;
                    displayTeamB = matchData.teamB;
                    if (!isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                        score = `${matchData.scoreA} - ${matchData.scoreB}`;
                    }
                    venue = matchData.venue || "TBD";
                    time = matchData.time || "TBD";
                    isNoData = false;
                } else {
                    // If potential teams are known, show them even if no data saved yet
                    if (sfPotentialPairings[i].teamA !== "TBD" && sfPotentialPairings[i].teamB !== "TBD" &&
                        sfPotentialPairings[i].teamA !== "DRAW" && sfPotentialPairings[i].teamB !== "DRAW") {
                        displayTeamA = sfPotentialPairings[i].teamA;
                        displayTeamB = sfPotentialPairings[i].teamB;
                    }
                }

                // Determine winner for Final pairing
                let winner = "TBD";
                if (matchData && !isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                    if (matchData.scoreA > matchData.scoreB) {
                        winner = matchData.teamA;
                    } else if (matchData.scoreB > matchData.scoreA) {
                        winner = matchData.teamB;
                    } else {
                        winner = "DRAW";
                    }
                }
                sfWinners[label] = winner; // Store SF winner

                sfHtml += `<div class="bracket-match ${isNoData ? 'no-data-message' : ''}">
                                <p class="teams">${label}: ${displayTeamA} vs ${displayTeamB}</p>
                                <p class="score">Score: ${score}</p>
                                <p class="venue-time">Venue: ${venue}, Time: ${time}</p>
                            </div>`;
            }
            document.getElementById('semiFinals').innerHTML = sfHtml;

            // --- Final ---
            let finalHtml = "";
            const finalLabel = "Final";
            // Determine Final pairing based on SF winners (actual determined winners or "TBD")
            const finalPotentialPairing = { teamA: sfWinners["SF1"], teamB: sfWinners["SF2"] };

            const firebaseMatchId_final = finalLabel; // Use the label as the Firestore document ID

            let displayTeamA_final = "TBD";
            let displayTeamB_final = "TBD";
            let score_final = "- (No Data)";
            let venue_final = "TBD";
            let time_final = "TBD";
            let isFinalNoData = true;

            const finalMatchData = knockoutMatchesData.final.find(m => m.id === firebaseMatchId_final); // Find by fixed ID
            
            if (finalMatchData && finalMatchData.teamA && finalMatchData.teamB) { // If match data exists and has valid team names
                displayTeamA_final = finalMatchData.teamA;
                displayTeamB_final = finalMatchData.teamB;
                if (!isNaN(parseInt(finalMatchData.scoreA)) && !isNaN(parseInt(finalMatchData.scoreB))) {
                    score_final = `${finalMatchData.scoreA} - ${finalMatchData.scoreB}`;
                }
                venue_final = finalMatchData.venue || "TBD";
                time_final = finalMatchData.time || "TBD";
                isFinalNoData = false;
            } else {
                // If potential teams are known, show them even if no data saved yet
                if (finalPotentialPairing.teamA !== "TBD" && finalPotentialPairing.teamB !== "TBD" &&
                    finalPotentialPairing.teamA !== "DRAW" && finalPotentialPairing.teamB !== "DRAW") {
                    displayTeamA_final = finalPotentialPairing.teamA;
                    displayTeamB_final = finalPotentialPairing.teamB;
                }
            }

            finalHtml += `<div class="bracket-match ${isFinalNoData ? 'no-data-message' : ''}">
                                <p class="teams">${finalLabel}: ${displayTeamA_final} vs ${displayTeamB_final}</p>
                                <p class="score">Score: ${score_final}</p>
                                <p class="venue-time">Venue: ${venue_final}, Time: ${time_final}</p>
                            </div>`;
            
            document.getElementById('finalMatch').innerHTML = finalHtml;

        } catch (error) {
            console.error("Error fetching Next Stage data: ", error);
            document.getElementById('quarterFinals').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Quarter Final data.</p></div>`;
            document.getElementById('semiFinals').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Semi Final data.</p></div>`;
            document.getElementById('finalMatch').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Final data.</p></div>`;
        }
    }

    // Fetches and displays data for the Group Stage (tables and match details).
    window.fetchGroupStageData = async function() {
        try {
            const { standingsByGroup, matchesByGroup, teamsByGroup } = await window.getGroupStageData();

            let groupTablesHtml = "<h3>Group Stage Standings</h3>";
            for (const group of window.groups) {
                const sortedStandings = standingsByGroup[group] || [];
                const groupTeams = teamsByGroup[group] || [];

                if (sortedStandings.length > 0 || groupTeams.length > 0) {
                    groupTablesHtml += `<h4>Group ${group} Standings</h4>`;
                    groupTablesHtml += `<table class="group-standings-table">
                                        <thead>
                                            <tr>
                                                <th>Team</th>
                                                <th>Played</th>
                                                <th>Win</th>
                                                <th>Loss</th>
                                                <th>Points</th>
                                                <th>Score+</th>
                                                <th>Score-</th>
                                                <th>Diff</th>
                                            </tr>
                                        </thead>
                                        <tbody>`;
                    if (sortedStandings.length > 0) {
                        sortedStandings.forEach(team => {
                            groupTablesHtml += `<tr>
                                                    <td>${team.teamName || 'N/A'}</td>
                                                    <td>${team.played}</td>
                                                    <td>${team.wins}</td>
                                                    <td>${team.losses}</td>
                                                    <td>${team.points}</td>
                                                    <td>${team.scoreFor}</td>
                                                    <td>${team.scoreAgainst}</td>
                                                    <td>${team.difference}</td>
                                                </tr>`;
                        });
                    } else if (groupTeams.length > 0) {
                           groupTeams.forEach(teamName => {
                               groupTablesHtml += `<tr>
                                                    <td>${teamName || 'N/A'}</td>
                                                    <td>0</td> <td>0</td> <td>0</td>
                                                    <td>0</td> <td>0</td> <td>0</td> <td>0</td>
                                                   </tr>`;
                           });
                    } else {
                           groupTablesHtml += `<tr><td colspan="8">No teams registered for this group.</td></tr>`;
                    }
                    groupTablesHtml += `</tbody></table>`;
                } else {
                    groupTablesHtml += `<h4>Group ${group} Standings</h4><p>No teams registered for Group ${group}.</p>`;
                }
            }
            document.getElementById('groupTables').innerHTML = groupTablesHtml;


            // --- Match Details ---
            let matchMatrixHtml = "<h3>Group Stage Match Details</h3>";
            for (const group of window.groups) {
                const groupDocRef = window.doc(window.db, "matchResults", group);
                const groupDocSnap = await window.getDoc(groupDocRef);
                
                const groupTeams = teamsByGroup[group] || [];
                groupTeams.sort();

                matchMatrixHtml += `<h4>Group ${group}</h4>`;

                if (groupTeams.length > 0) {
                    const venue = groupDocSnap.exists() ? (groupDocSnap.data().venue || 'N/A') : 'N/A';
                    const time = groupDocSnap.exists() ? (groupDocSnap.data().time || 'N/A') : 'N/A';
                    matchMatrixHtml += `<div class="venue-time">Venue: ${venue}, Time: ${time}</div>`;

                    matchMatrixHtml += `<table class="match-matrix-table">
                                        <thead>
                                            <tr>
                                                <th></th>`;
                    groupTeams.forEach(team => {
                        matchMatrixHtml += `<th>${team}</th>`;
                    });
                    matchMatrixHtml += `</tr></thead><tbody>`;
                    groupTeams.forEach(rowTeam => {
                        rowTeam = rowTeam.trim(); // Ensure no leading/trailing spaces
                        rowTeam = rowTeam.replace(/\s+/g, '_'); // Replace spaces with underscores for key
                        matchMatrixHtml += `<tr><th>${rowTeam.replace(/_/g, ' ')}</th>`; // Display original name

                        groupTeams.forEach(colTeam => {
                            colTeam = colTeam.trim(); // Ensure no leading/trailing spaces
                            colTeam = colTeam.replace(/\s+/g, '_'); // Replace spaces with underscores for key

                            if (rowTeam === colTeam) {
                                matchMatrixHtml += `<td class="empty-cell"></td>`;
                            } else {
                                let score = "-";
                                if (groupDocSnap.exists() && matchesByGroup[group]) {
                                    const matches = matchesByGroup[group];
                                    // Canonical key for consistency (alphabetical order of teams)
                                    const team1_key = rowTeam;
                                    const team2_key = colTeam;
                                    const matchKeyCanonical = team1_key < team2_key ? 
                                                              `${team1_key} vs ${team2_key}` : 
                                                              `${team2_key} vs ${team1_key}`;
                                    
                                    let actualScoreString = '';
                                    if (matches[matchKeyCanonical]) {
                                        actualScoreString = matches[matchKeyCanonical];
                                    }

                                    if (actualScoreString) {
                                        const scoresParts = actualScoreString.split('-');
                                        if (scoresParts.length === 2) {
                                            const scoreA_from_db = parseInt(scoresParts[0]); // Score for the first team in the canonical key
                                            const scoreB_from_db = parseInt(scoresParts[1]); // Score for the second team in the canonical key

                                            // Determine which team from the canonical matchKey corresponds to rowTeam
                                            // Then display score in rowTeam vs colTeam order
                                            const canonicalTeamsInKey = matchKeyCanonical.split(' vs ');
                                            const canonicalTeamA = canonicalTeamsInKey[0]; // First team in alphabetical order
                                            // const canonicalTeamB = canonicalTeamsInKey[1]; // Not directly used here

                                            if (rowTeam === canonicalTeamA) { 
                                                score = `${scoreA_from_db}-${scoreB_from_db}`;
                                            } else { 
                                                score = `${scoreB_from_db}-${scoreA_from_db}`; // Reverse order for display
                                            }
                                        }
                                    }
                                }
                                matchMatrixHtml += `<td class="score-cell">${score}</td>`;
                            }
                        });
                        matchMatrixHtml += `</tr>`;
                    });
                    matchMatrixHtml += `</tbody></table>`;
                } else {
                    matchMatrixHtml += `<p>No teams registered for this group yet.</p>`;
                }
            }
            document.getElementById('matchMatrix').innerHTML = matchMatrixHtml;

        } catch (error) {
            console.error("Error fetching Group Stage data: ", error);
            document.getElementById('groupTables').innerHTML = "<p>Error loading group stage tables.</p>";
            document.getElementById('matchMatrix').innerHTML = "<p>Error loading match details. </p>";
        }
    }

    // Fetches and displays all fixtures
    window.fetchAllFixtures = async function() {
        try {
            // Note: teamsByGroup is still fetched but NOT used for generating fixtures
            const { teamsByGroup } = await window.getGroupStageData();
            let fixturesHtml = "";

            // Group Stage Fixtures (Generated Locally using round-robin method, then reordered and limited to 10)
            fixturesHtml += "<h3>Group Stage Fixtures</h3>";
            for (let i = 0; i < window.groups.length; i++) {
                const group = window.groups[i];
                // Use generic teams for fixture generation, NOT from DB for this tab
                // Ensure to pass numTeams=5 for 5 team limit
                const genericGroupTeams = getGroupFixtureTeams(group, 5); 
                const groupVenue = venues[group] || 'TBD';

                fixturesHtml += `<div class="fixtures-table-container">`;
                fixturesHtml += `<h4>Group ${group} Fixtures (Venue: ${groupVenue})</h4>`;
                
                if (genericGroupTeams.length > 1) { // Ensure there are enough generic teams
                    const allRoundRobinMatches = generateRoundRobinFixtures(genericGroupTeams);
                    // Use the new function to order matches as per user's specific request
                    // Then limit to the first 10 matches
                    const matchesToDisplay = orderFixturesForUserDisplay(allRoundRobinMatches, genericGroupTeams).slice(0, 10); 

                    fixturesHtml += `<table>
                                    <thead>
                                        <tr>
                                            <th>Match</th>
                                            <th>Team</th>
                                            <th>Time</th>
                                        </tr>
                                    </thead>
                                    <tbody>`;
                    
                    matchesToDisplay.forEach((teamPair, matchIndex) => { // Iterate over the ordered list
                        const matchNumber = matchIndex + 1;
                        const matchTime = getMatchTime(matchIndex);
                        fixturesHtml += `<tr>
                                            <td>${matchNumber}</td>
                                            <td>${teamPair}</td>
                                            <td>${matchTime}</td>
                                        </tr>`;
                    });
                    fixturesHtml += `</tbody></table>`;
                } else {
                    // Fallback message if generic teams are not enough (shouldn't happen with numTeams=5)
                    fixturesHtml += `<p>Not enough teams to generate a full fixed fixture list for Group ${group} (minimum 2 teams required).</p>`;
                }
                fixturesHtml += `</div>`;
            }

            // Knockout Stage Fixtures (Hardcoded as per user's image request, now in table format)
            fixturesHtml += "<h3>Knockout Stage Fixtures</h3>";

            // Quarter Finals
            fixturesHtml += `<h4>Quarter Final Fixtures</h4>`;
            fixturesHtml += `<table>
                                <thead>
                                    <tr>
                                        <th>Match</th>
                                        <th>Teams</th>
                                        <th>Venue</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>QF1</td>
                                        <td>Rank 1 vs Rank 8</td>
                                        <td></td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td>QF2</td>
                                        <td>Rank 4 vs Rank 5</td>
                                        <td></td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td>QF3</td>
                                        <td>Rank 2 vs Rank 7</td>
                                        <td></td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td>QF4</td>
                                        <td>Rank 3 vs Rank 6</td>
                                        <td></td>
                                        <td></td>
                                    </tr>
                                </tbody>
                            </table>`;

            // Semi Finals
            fixturesHtml += `<h4>Semi Final Fixtures</h4>`;
            fixturesHtml += `<table>
                                <thead>
                                    <tr>
                                        <th>Match</th>
                                        <th>Teams</th>
                                        <th>Venue</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>SF1</td>
                                        <td>Winner QF1 vs Winner QF2</td>
                                        <td></td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td>SF2</td>
                                        <td>Winner QF3 vs Winner QF4</td>
                                        <td></td>
                                        <td></td>
                                    </tr>
                                </tbody>
                            </table>`;

            // Final
            fixturesHtml += `<h4>Final Fixture</h4>`;
            fixturesHtml += `<table>
                                <thead>
                                    <tr>
                                        <th>Match</th>
                                        <th>Teams</th>
                                        <th>Venue</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Final</td>
                                        <td>Winner SF1 vs Winner SF2</td>
                                        <td></td>
                                        <td></td>
                                    </tr>
                                </tbody>
                            </table>`;

            document.getElementById('fixturesContent').innerHTML = fixturesHtml;

        } catch (error) {
            console.error("Error fetching fixtures: ", error);
            document.getElementById('fixturesContent').innerHTML = "<p>Error loading fixtures.</p>";
        }
    }


    // PDF Generation Functions (retained from previous versions and updated for correct knockout data fetching)
    window.downloadResultsPdf = async function() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        doc.setFontSize(18);
        doc.text("Petanque Match Results", 105, 20, null, null, "center");

        const { standingsByGroup, matchesByGroup } = await window.getGroupStageData();

        let yOffset = 30;

        // Group Stage Tables
        doc.setFontSize(14);
        doc.text("Group Stage Standings", 14, yOffset + 10);
        yOffset += 20;

        for (const group of window.groups) {
            const sortedStandings = standingsByGroup[group] || [];
            if (sortedStandings.length > 0) {
                doc.setFontSize(12);
                doc.text(`Group ${group} Standings`, 14, yOffset);
                yOffset += 10;

                const tableData = sortedStandings.map(team => [
                    team.teamName,
                    team.played,
                    team.wins,
                    team.losses,
                    team.points,
                    team.scoreFor,
                    team.scoreAgainst,
                    team.difference
                ]);

                doc.autoTable({
                    head: [['Team', 'Played', 'Win', 'Loss', 'Points', 'Score+', 'Score-', 'Diff']],
                    body: tableData,
                    startY: yOffset,
                    theme: 'grid',
                    headStyles: { fillColor: [30, 144, 255] },
                    didDrawPage: function (data) {
                        yOffset = data.cursor.y + 10;
                    }
                });
                yOffset = doc.autoTable.previous.finalY + 10;
            }
        }

        // Match Details
        doc.addPage(); // Start match details on a new page
        yOffset = 20;
        doc.setFontSize(14);
        doc.text("Group Stage Match Details", 14, yOffset);
        yOffset += 10;

        for (const group of window.groups) {
            const groupDocRef = window.doc(window.db, "matchResults", group);
            const groupDocSnap = await window.getDoc(groupDocRef);
            const groupTeams = (await window.getGroupStageData()).teamsByGroup[group] || [];
            groupTeams.sort();

            doc.setFontSize(12); // Corrected this line from doc.setFontSize(1(2);
            doc.text(`Group ${group}`, 14, yOffset);
            yOffset += 7;

            const venue = groupDocSnap.exists() ? (groupDocSnap.data().venue || 'N/A') : 'N/A';
            const time = groupDocSnap.exists() ? (groupDocSnap.data().time || 'N/A') : 'N/A';
            doc.setFontSize(10);
            doc.text(`Venue: ${venue}, Time: ${time}`, 14, yOffset);
            yOffset += 7;

            if (groupTeams.length > 0) {
                const header = ['', ...groupTeams];
                const body = groupTeams.map(rowTeam => {
                    rowTeam = rowTeam.trim(); // Ensure no leading/trailing spaces
                    const row = [rowTeam];
                    groupTeams.forEach(colTeam => {
                        colTeam = colTeam.trim(); // Ensure no leading/trailing spaces
                        if (rowTeam === colTeam) {
                            row.push('');
                        } else {
                            let score = "-";
                            if (groupDocSnap.exists() && matchesByGroup[group]) {
                                const matches = matchesByGroup[group];
                                // Canonical key for consistency (alphabetical order of teams)
                                const team1_key = rowTeam.replace(/\s+/g, '_'); // Use underscores for internal key
                                const team2_key = colTeam.replace(/\s+/g, '_'); // Use underscores for internal key
                                const matchKeyCanonical = team1_key < team2_key ? 
                                                              `${team1_key} vs ${team2_key}` : 
                                                              `${team2_key} vs ${team1_key}`;
                                
                                let actualScoreString = '';
                                if (matches[matchKeyCanonical]) {
                                    actualScoreString = matches[matchKeyCanonical];
                                }

                                if (actualScoreString) {
                                    const scoresParts = actualScoreString.split('-');
                                    if (scoresParts.length === 2) {
                                        const scoreA_from_db = parseInt(scoresParts[0]); // Score for the first team in the canonical key
                                        const scoreB_from_db = parseInt(scoresParts[1]); // Score for the second team in the canonical key

                                        // Determine which team from the canonical matchKey corresponds to rowTeam
                                        // Then display score in rowTeam vs colTeam order
                                        const canonicalTeamsInKey = matchKeyCanonical.split(' vs ');
                                        const canonicalTeamA = canonicalTeamsInKey[0]; // First team in alphabetical order
                                        // const canonicalTeamB = canonicalTeamsInKey[1]; // Not directly used here

                                        if (rowTeam.replace(/\s+/g, '_') === canonicalTeamA) { // Compare trimmed names with underscores
                                            score = `${scoreA_from_db}-${scoreB_from_db}`;
                                        } else { // rowTeam is the other team in the canonical pair
                                            score = `${scoreB_from_db}-${scoreA_from_db}`; // Reverse order for display
                                        }
                                    }
                                }
                            }
                            row.push(score);
                        }
                    });
                    return row;
                });

                doc.autoTable({
                    head: [header],
                    body: body,
                    startY: yOffset,
                    theme: 'grid',
                    headStyles: { fillColor: [30, 144, 255] },
                    didDrawPage: function (data) {
                        yOffset = data.cursor.y + 10;
                    }
                });
                yOffset = doc.autoTable.previous.finalY + 10;
            } else {
                doc.text("No teams registered for this group yet.", 14, yOffset);
                yOffset += 10;
            }
        }


        // Knockout Stage Results
        doc.addPage();
        yOffset = 20;
        doc.setFontSize(16);
        doc.text("Knockout Stage Results", 105, yOffset, null, null, "center");
        yOffset += 15;

        const knockoutStages = [
            { id: "quarter_finals", title: "Quarter Finals", labels: ["QF1", "QF2", "QF3", "QF4"] },
            { id: "semi_finals", title: "Semi Finals", labels: ["SF1", "SF2"] },
            { id: "final", title: "Final", labels: ["Final"] }
        ];

        for (const stage of knockoutStages) {
            doc.setFontSize(14);
            doc.text(stage.title, 14, yOffset);
            yOffset += 10;

            const matchesRef = window.collection(window.doc(window.db, "knockoutMatches", stage.id), "matches");
            const snapshot = await window.getDocs(matchesRef);
            const actualMatches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            if (stage.id === "quarter_finals") {
                const { standingsByGroup } = await window.getGroupStageData();
                let groupWinners = [];
                let allRunnersUp = [];
                for (const group of window.groups) {
                    const groupStandings = standingsByGroup[group];
                    if (groupStandings && groupStandings.length >= 1 && groupStandings[0].teamName !== "TBD") {
                        groupWinners.push(groupStandings[0]);
                    }
                    if (groupStandings && groupStandings.length >= 2 && groupStandings[1].teamName !== "TBD") {
                        allRunnersUp.push(groupStandings[1]);
                    }
                }
                allRunnersUp.sort(compareTeamStandings);
                const top2RunnersUp = allRunnersUp.slice(0, 2);
                const qualifiers = [...groupWinners, ...top2RunnersUp].sort(compareTeamStandings);

                const qfPotentialPairings = [
                    { teamA: qualifiers[0]?.teamName || "TBD", teamB: qualifiers[7]?.teamName || "TBD" },
                    { teamA: qualifiers[3]?.teamName || "TBD", teamB: qualifiers[4]?.teamName || "TBD" },
                    { teamA: qualifiers[1]?.teamName || "TBD", teamB: qualifiers[6]?.teamName || "TBD" },
                    { teamA: qualifiers[2]?.teamName || "TBD", teamB: qualifiers[5]?.teamName || "TBD" }
                ];

                stage.labels.forEach((label, index) => {
                    const matchData = actualMatches.find(m => m.id === label);
                    let displayTeamA = qfPotentialPairings[index].teamA;
                    let displayTeamB = qfPotentialPairings[index].teamB;
                    let score = "- (No Data)";
                    let venue = ""; // Set to empty string for results PDF as well
                    let time = ""; // Set to empty string for results PDF as well

                    if (matchData && matchData.teamA && matchData.teamB) {
                        displayTeamA = matchData.teamA;
                        displayTeamB = matchData.teamB;
                        if (!isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                            score = `${matchData.scoreA} - ${matchData.scoreB}`;
                        }
                        // venue and time for results are still loaded from matchData if available
                        venue = matchData.venue || "";
                        time = matchData.time || "";
                    } else if (qualifiers.length < 8) {
                        score = "- (Not enough qualifiers)";
                    }
                    doc.setFontSize(11);
                    doc.text(`${label}: ${displayTeamA} vs ${displayTeamB} (Score: ${score}, Venue: ${venue}, Time: ${time})`, 14, yOffset);
                    yOffset += 7;
                });
            } else if (stage.id === "semi_finals") {
                const sfPotentialPairings = [
                    { teamA: "Winner QF1", teamB: "Winner QF2" },
                    { teamA: "Winner QF3", teamB: "Winner QF4" }
                ];
                stage.labels.forEach((label, index) => {
                    const matchData = actualMatches.find(m => m.id === label);
                    let displayTeamA = sfPotentialPairings[index].teamA;
                    let displayTeamB = sfPotentialPairings[index].teamB;
                    let score = "- (No Data)";
                    let venue = ""; // Set to empty string
                    let time = ""; // Set to empty string

                    if (matchData && matchData.teamA && matchData.teamB) {
                        displayTeamA = matchData.teamA;
                        displayTeamB = matchData.teamB;
                        if (!isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                            score = `${matchData.scoreA} - ${matchData.scoreB}`;
                        }
                        venue = matchData.venue || "";
                        time = matchData.time || "";
                    }
                    doc.setFontSize(11);
                    doc.text(`${label}: ${displayTeamA} vs ${displayTeamB} (Score: ${score}, Venue: ${venue}, Time: ${time})`, 14, yOffset);
                    yOffset += 7;
                });

            } else if (stage.id === "final") {
                const finalPotentialPairing = { teamA: "Winner SF1", teamB: "Winner SF2" };
                const label = stage.labels[0];
                const matchData = actualMatches.find(m => m.id === label);
                let displayTeamA = finalPotentialPairing.teamA;
                let displayTeamB = finalPotentialPairing.teamB;
                let score = "- (No Data)";
                let venue = ""; // Set to empty string
                let time = ""; // Set to empty string

                if (matchData && matchData.teamA && matchData.teamB) {
                    displayTeamA = matchData.teamA;
                    displayTeamB = matchData.teamB;
                    if (!isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                        score = `${matchData.scoreA} - ${matchData.scoreB}`;
                    }
                    venue = matchData.venue || "";
                    time = matchData.time || "";
                }
                doc.setFontSize(11);
                doc.text(`${label}: ${displayTeamA} vs ${displayTeamB} (Score: ${score}, Venue: ${venue}, Time: ${time})`, 14, yOffset);
                yOffset += 7;
            }
            yOffset += 5; // Add some space between stages
        }

        doc.save("Petanque_Results.pdf");
    }

    window.downloadFixturesPdf = async function() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        doc.setFontSize(18);
        doc.text("Petanque Fixtures", 105, 20, null, null, "center");

        let yOffset = 30;

        // Group Stage Fixtures (Generated Locally)
        doc.setFontSize(14);
        doc.text("Group Stage Fixtures", 14, yOffset + 10);
        yOffset += 20;

        for (let i = 0; i < window.groups.length; i++) {
            const group = window.groups[i];
            // Ensure to pass numTeams=5 for 5 team limit
            const genericGroupTeams = getGroupFixtureTeams(group, 5); 
            const groupVenue = venues[group] || 'TBD';

            doc.setFontSize(12);
            doc.text(`Group ${group} Fixtures (Venue: ${groupVenue})`, 14, yOffset);
            yOffset += 10;

            if (genericGroupTeams.length > 1) {
                const allRoundRobinMatches = generateRoundRobinFixtures(genericGroupTeams);
                const matchesToDisplay = orderFixturesForUserDisplay(allRoundRobinMatches, genericGroupTeams).slice(0, 10); 

                const tableData = matchesToDisplay.map((teamPair, matchIndex) => {
                    const matchNumber = matchIndex + 1;
                    const matchTime = getMatchTime(matchIndex);
                    return [matchNumber, teamPair, matchTime];
                });

                doc.autoTable({
                    head: [['Match', 'Team', 'Time']],
                    body: tableData,
                    startY: yOffset,
                    theme: 'grid',
                    headStyles: { fillColor: [30, 144, 255] },
                    didDrawPage: function (data) {
                        yOffset = data.cursor.y + 10;
                    }
                });
                yOffset = doc.autoTable.previous.finalY + 10;
            } else {
                doc.setFontSize(11);
                doc.text(`Not enough teams to generate a full fixed fixture list for Group ${group} (minimum 2 teams required).`, 14, yOffset);
                yOffset += 10;
            }
        }


        // Knockout Stage Fixtures (Hardcoded as per user's image, now in table format)
        doc.addPage();
        yOffset = 20;
        doc.setFontSize(16);
        doc.text("Knockout Stage Fixtures", 105, yOffset, null, null, "center");
        yOffset += 15;

        // Quarter Finals Fixtures - Hardcoded with empty Venue and Time
        doc.setFontSize(14);
        doc.text("Quarter Final", 14, yOffset);
        yOffset += 10;
        const qfData = [
            ['QF1', 'Rank 1 vs Rank 8', '', ''], // Changed from 'TBD' to ''
            ['QF2', 'Rank 4 vs Rank 5', '', ''], // Changed from 'TBD' to ''
            ['QF3', 'Rank 2 vs Rank 7', '', ''], // Changed from 'TBD' to ''
            ['QF4', 'Rank 3 vs Rank 6', '', '']  // Changed from 'TBD' to ''
        ];
        doc.autoTable({
            head: [['Match', 'Teams', 'Venue', 'Time']],
            body: qfData,
            startY: yOffset,
            theme: 'grid',
            headStyles: { fillColor: [30, 144, 255] },
            didDrawPage: function (data) {
                yOffset = data.cursor.y + 10;
            }
        });
        yOffset = doc.autoTable.previous.finalY + 10;

        // Semi Finals Fixtures - Hardcoded with empty Venue and Time
        doc.setFontSize(14);
        doc.text("Semi Final", 14, yOffset);
        yOffset += 10;
        const sfData = [
            ['SF1', 'Winner QF1 vs Winner QF2', '', ''], // Changed from 'TBD' to ''
            ['SF2', 'Winner QF3 vs Winner QF4', '', '']  // Changed from 'TBD' to ''
        ];
        doc.autoTable({
            head: [['Match', 'Teams', 'Venue', 'Time']],
            body: sfData,
            startY: yOffset,
            theme: 'grid',
            headStyles: { fillColor: [30, 144, 255] },
            didDrawPage: function (data) {
                yOffset = data.cursor.y + 10;
            }
        });
        yOffset = doc.autoTable.previous.finalY + 10;

        // Final Fixture - Hardcoded with empty Venue and Time
        doc.setFontSize(14);
        doc.text("Final", 14, yOffset);
        yOffset += 10;
        const finalData = [
            ['Final', 'Winner SF1 vs Winner SF2', '', ''] // Changed from 'TBD' to ''
        ];
        doc.autoTable({
            head: [['Match', 'Teams', 'Venue', 'Time']],
            body: finalData,
            startY: yOffset,
            theme: 'grid',
            headStyles: { fillColor: [30, 144, 255] },
            didDrawPage: function (data) {
                yOffset = data.cursor.y + 10;
            }
        });
        yOffset = doc.autoTable.previous.finalY + 10;


        doc.save("Petanque_Fixtures.pdf");
    }

    // Initial data load when the page loads
    document.addEventListener('DOMContentLoaded', async () => {
        await window.fetchGroupStageData();
        await window.fetchNextStageData();
        await window.fetchAllFixtures(); // Load fixtures data
    });
  </script>
</body>
</html>
