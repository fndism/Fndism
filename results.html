<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Petanque Results</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f9fa;
      padding: 20px;
      min-height: 100vh; /* Ensure body takes full viewport height for footer positioning */
      display: flex;
      flex-direction: column;
    }
    h1 {
      text-align: center;
      color: #343a40;
      margin-bottom: 30px;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center; /* Center the tabs */
    }
    .tab {
      padding: 10px 20px;
      background: #007bff;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold; /* Make tab text bolder */
      transition: background-color 0.3s ease; /* Smooth transition for hover */
    }
    .tab:hover {
      background: #0056b3; /* Darker blue on hover */
    }
    .tab.active {
      background: #0056b3;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add shadow to active tab */
    }
    .tab-content {
      display: none;
      padding: 15px; /* Add some padding to content */
      background: #fff; /* White background for content */
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      flex-grow: 1; /* Allow content to grow and push footer down */
    }
    .tab-content.active {
      display: block;
    }
    h2 {
      color: #007bff;
      border-bottom: 2px solid #007bff;
      padding-bottom: 5px;
      margin-top: 25px;
      margin-bottom: 15px;
    }
    h3 { /* Style for sub-sections like "Group Stage Tables" */
        color: #343a40;
        font-size: 1.5em;
        margin-top: 20px;
        margin-bottom: 15px;
        text-align: center;
    }
    h4 { /* Style for individual group headers */
        color: #0056b3;
        font-size: 1.2em;
        margin-top: 15px;
        margin-bottom: 10px;
        text-align: left;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* Subtle shadow for tables */
    }
    th, td {
      border: 1px solid #ccc;
      text-align: center;
      padding: 10px; /* Increased padding */
    }
    th {
      background: #e9ecef;
      color: #343a40;
      font-weight: bold;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2; /* Zebra striping for tables */
    }
    .match-info, .knockout {
      background: #fff;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .match-info p {
      margin: 5px 0; /* Spacing for match info */
    }
    .match-info .score {
      font-weight: bold;
      color: #dc3545; /* Red for scores */
    }
    .match-info .teams {
      font-size: 1.1em;
      font-weight: bold;
    }
    .venue-time {
      font-style: italic;
      margin-top: 5px;
      color: #6c757d;
      font-size: 0.9em;
    }
    /* Specific styling for the Match Details table */
    .match-matrix-table td.empty-cell {
        background-color: #eee;
    }
    .match-matrix-table td.score-cell {
        font-weight: bold;
        color: #0056b3;
    }

    /* --- Knockout Bracket Styling --- */
    .tournament-bracket {
        display: grid;
        grid-template-columns: repeat(3, 1fr); /* QF, SF, Final */
        gap: 10px;
        max-width: 900px; /* Max width for the bracket */
        margin: 20px auto;
        padding: 20px;
        background: #fdfdfd;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        text-align: center;
    }
    .bracket-stage {
        display: flex;
        flex-direction: column;
        justify-content: space-around; /* Distribute matches evenly by default */
        padding: 10px 0;
    }
    .bracket-stage.quarter-finals-stage {
        grid-column: 1 / 2; /* First column */
    }
    .bracket-stage.semi-finals-stage {
        grid-column: 2 / 3; /* Second column */
        justify-content: center; /* ALIGNMENT FIX: Center content vertically for semi-finals */
    }
    .bracket-stage.final-stage {
        grid-column: 3 / 4; /* Third column */
        justify-content: center; /* Center the final match */
    }

    .bracket-match {
        background: #e9f5ff; /* Light blue for match boxes */
        border: 1px solid #cceeff;
        border-radius: 8px;
        padding: 10px;
        margin: 10px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        position: relative; /* For connecting lines */
        min-height: 80px; /* Ensure consistent height */
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .bracket-match .teams {
        font-weight: bold;
        color: #333;
        font-size: 0.95em;
    }
    .bracket-match .score {
        color: #dc3545;
        font-weight: bold;
        font-size: 0.9em;
        margin-top: 5px;
    }
    .bracket-match .venue-time {
        font-size: 0.8em;
        color: #666;
        margin-top: 5px;
    }

    /* Connecting Lines - simplified for display */
    .bracket-match::after, .bracket-match::before {
        content: '';
        position: absolute;
        background: #999;
        z-index: 1;
    }
    .bracket-stage.quarter-finals-stage .bracket-match::after {
        top: 50%;
        right: -5px; /* Connects to the next stage container boundary */
        width: 5px;
        height: 1px;
        transform: translateY(-50%);
    }
    .bracket-stage.semi-finals-stage .bracket-match::after {
        top: 50%;
        right: -5px;
        width: 5px;
        height: 1px;
        transform: translateY(-50%);
    }

    /* Vertical connector for SF to Final */
    .bracket-stage.semi-finals-stage .bracket-match:first-child::before {
        content: '';
        position: absolute;
        bottom: -15px; /* Adjust based on match spacing */
        left: 50%;
        width: 1px;
        height: 30px; /* Length of vertical line */
        background: #999;
        transform: translateX(-50%);
        z-index: 0;
    }
    
    /* Hide lines for placeholder/empty messages */
    .bracket-match.no-data-message::after,
    .bracket-match.no-data-message::before {
        display: none;
    }

    @media (max-width: 768px) {
        .tournament-bracket {
            grid-template-columns: 1fr; /* Stack columns on smaller screens */
        }
        .bracket-stage {
            border-bottom: 1px solid #eee; /* Separate stages */
            margin-bottom: 10px;
        }
        .bracket-stage:last-child {
            border-bottom: none;
        }
        .bracket-match::after,
        .bracket-match::before,
        .semi-finals-stage .bracket-match::before {
            display: none; /* Hide lines on mobile */
        }
    }

    /* Styling for the new Fixtures tab */
    .fixtures-table {
        width: 100%;
        border-collapse: collapse;
        margin: 15px 0;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .fixtures-table th, .fixtures-table td {
        border: 1px solid #ccc;
        text-align: center;
        padding: 10px;
    }
    .fixtures-table th {
        background: #e9ecef;
        color: #343a40;
        font-weight: bold;
    }
    .fixtures-table tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    .fixtures-table .group-heading {
        background-color: #d1ecf1; /* Light blue background for group headings */
        font-weight: bold;
        color: #0c5460;
        text-align: left;
    }
    .fixtures-table .match-details {
        font-weight: normal;
        color: #343a40;
    }


    /* Footer styling */
    .footer {
        margin-top: auto; /* Push footer to the bottom */
        padding-top: 20px;
        text-align: center;
        font-size: 0.9em;
        color: #777;
    }

    .download-button-container {
        text-align: center;
        margin-top: 20px;
        margin-bottom: 20px;
    }

    .download-pdf-button {
        background-color: #dc3545; /* Red for PDF */
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
    }
    .download-pdf-button:hover {
        background-color: #c82333; /* Darker red on hover */
    }
  </style>
</head>
<body>
  <h1>SMZ18201: Petanque Match Results</h1>

  <div class="tabs">
    <div class="tab active" onclick="window.switchTab('groupStage')">Group Stage</div>
    <div class="tab" onclick="window.switchTab('nextStage')">Next Stage</div>
    <div class="tab" onclick="window.switchTab('fixtures')">Fixtures</div> <!-- New Tab -->
    <div class="tab" onclick="window.location.href='index.html'">⬅ Homepage</div>
  </div>

  <div class="download-button-container">
    <button onclick="window.downloadResultsPdf()" class="download-pdf-button">
      ⬇ Download Results as PDF
    </button>
  </div>

  <!-- Group Stage Content - now active by default -->
  <div id="groupStage" class="tab-content active">
    <h2 id="groupStageTablesHeader">Group Stage Tables</h2>
    <div id="groupTables">Loading group tables...</div>
    <h2 id="groupMatchDetailsHeader">Match Details</h2>
    <div id="matchMatrix">Loading match details...</div>
  </div>

  <!-- Next Stage Content - now inactive by default -->
  <div id="nextStage" class="tab-content">
    <!-- Tournament Bracket Container -->
    <div class="tournament-bracket">
        <div class="bracket-stage quarter-finals-stage">
            <h2>Quarter Final</h2>
            <div id="quarterFinals">Loading Quarter Final matches...</div>
        </div>

        <div class="bracket-stage semi-finals-stage">
            <h2>Semi Final</h2>
            <div id="semiFinals">Loading Semi Final matches...</div>
        </div>

        <div class="bracket-stage final-stage">
            <h2>Final</h2>
            <div id="finalMatch">Loading Final match...</div>
        </div>
    </div>
  </div>

  <!-- New Fixtures Content Tab -->
  <div id="fixtures" class="tab-content">
    <h2>All Scheduled Matches (Fixtures)</h2>
    <div class="download-button-container">
        <button onclick="window.downloadFixturesPdf()" class="download-pdf-button">
            ⬇ Download Fixtures as PDF
        </button>
    </div>
    <div id="fixturesContent">Loading fixtures...</div>
  </div>

  <div class="footer">
    <p>&copy; 2025 Fndism. All rights reserved.</p>
  </div>

  <!-- jsPDF and jspdf-autotable CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

  <script type="module">
    // Firebase configuration and initialization
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, getDoc } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDpS-kqwQDgdqiVK2kwXGB9a3B7WeJI_Iw",
      authDomain: "unimap-petanque.firebaseapp.com",
      projectId: "unimap-petanque",
      storageBucket: "unimap-petanque.appspot.com",
      messagingSenderId: "578920021890",
      appId: "1:578920021890:web:987ed2de28e7b0353c999b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Define groups array
    window.groups = ["A", "B", "C", "D", "E", "F"];

    // Make switchTab globally accessible
    window.switchTab = function(tabId) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      // Find the tab element by its onclick attribute to apply active class
      const targetTabElement = document.querySelector(`.tab[onclick*="switchTab('${tabId}')"]`);
      // Special handling for Homepage tab as it uses window.location.href
      if (tabId === 'homepage') {
          document.querySelector(`.tab[onclick*="window.location.href='index.html'"]`).classList.add('active');
      } else if (targetTabElement) {
          targetTabElement.classList.add('active');
      }
      document.getElementById(tabId).classList.add('active');
    }

    // Helper function to compare team standings for sorting.
    function compareTeamStandings(a, b) {
        if (b.points !== a.points) return b.points - a.points;
        if (b.difference !== a.difference) return b.difference - a.difference;
        if (b.scoreFor !== a.scoreFor) return a.teamName.localeCompare(b.teamName);
    }

    // Fetches and processes all group stage data
    window.getGroupStageData = async function() {
        const result = {
            standingsByGroup: {},
            matchesByGroup: {},
            teamsByGroup: {}
        };

        const teamsSnapshot = await getDocs(collection(db, "teams"));
        teamsSnapshot.forEach(documentSnapshot => { // Renamed 'doc' to 'documentSnapshot'
            const data = documentSnapshot.data();
            const group = data.group;
            const teamName = data.teamName;
            if (group && teamName) {
                if (!result.teamsByGroup[group]) result.teamsByGroup[group] = [];
                result.teamsByGroup[group].push(teamName);
            }
        });

        for (const group of window.groups) {
            const groupDocRef = doc(db, "matchResults", group);
            const groupDocSnap = await getDoc(groupDocRef);

            const groupTeams = result.teamsByGroup[group] || [];
            groupTeams.sort();

            const standings = {};
            groupTeams.forEach(teamName => {
                standings[teamName] = {
                    teamName: teamName,
                    played: 0, wins: 0, losses: 0, draws: 0,
                    points: 0, scoreFor: 0, scoreAgainst: 0, difference: 0
                };
            });

            if (groupDocSnap.exists() && groupDocSnap.data().matches) {
                const matches = groupDocSnap.data().matches;
                result.matchesByGroup[group] = matches;
                
                for (const matchKey in matches) {
                    if (matches.hasOwnProperty(matchKey)) {
                        const scoreStr = matches[matchKey];
                        const parts = matchKey.replace(/_/g, ' ').split(' vs ');
                        let teamA = parts[0] ? parts[0].trim() : null;
                        let teamB = parts[1] ? parts[1].trim() : null;

                        if (!teamA || !teamB || !standings[teamA] || !standings[teamB]) {
                            console.warn(`Skipping match ${matchKey} in group ${group}: Team data not found or invalid.`);
                            continue;
                        }

                        const scoreParts = scoreStr.split('-');
                        if (scoreParts.length === 2) {
                            let scoreA = parseInt(scoreParts[0]);
                            let scoreB = parseInt(scoreParts[1]);

                            if (!isNaN(scoreA) && !isNaN(scoreB)) {
                                standings[teamA].played++; standings[teamB].played++;
                                standings[teamA].scoreFor += scoreA; standings[teamA].scoreAgainst += scoreB;
                                standings[teamB].scoreFor += scoreB; standings[teamB].scoreAgainst += scoreA;

                                if (scoreA > scoreB) {
                                    standings[teamA].wins++; standings[teamB].losses++; standings[teamA].points += 3;
                                } else if (scoreB > scoreA) {
                                    standings[teamB].wins++; standings[teamA].losses++; standings[teamB].points += 3;
                                } else {
                                    standings[teamA].draws++; standings[teamB].draws++;
                                    standings[teamA].points += 1; standings[teamB].points += 1;
                                }
                            }
                        }
                    }
                }
            }

            let sortedStandings = Object.values(standings).map(teamStat => {
                teamStat.difference = teamStat.scoreFor - teamStat.scoreAgainst;
                return teamStat;
            }).sort(compareTeamStandings);

            result.standingsByGroup[group] = sortedStandings;
        }
        return result;
    }

    // Fetches and displays data for the Next Stage (Quarter, Semi, Final).
    window.fetchNextStageData = async function() { // Made globally accessible
        try {
            const { standingsByGroup } = await window.getGroupStageData();

            let groupWinners = [];
            let allRunnersUp = [];

            for (const group of window.groups) {
                const groupStandings = standingsByGroup[group];
                if (groupStandings && groupStandings.length >= 1) {
                    groupWinners.push(groupStandings[0]);
                    if (groupStandings.length >= 2) {
                        allRunnersUp.push(groupStandings[1]);
                    }
                }
            }

            allRunnersUp.sort(compareTeamStandings);
            const top2RunnersUp = allRunnersUp.slice(0, 2);

            let qualifiers = [...groupWinners, ...top2RunnersUp];
            qualifiers.sort(compareTeamStandings);

            // Fetch actual knockout match results if they exist (for SF/Final)
            const knockoutMatches = {
                quarter_finals: [],
                semi_finals: [],
                final: []
            };

            const qfSnapshot = await getDocs(collection(db, "knockoutMatches", "quarter_finals", "matches"));
            // Renamed 'doc' to 'documentSnapshot' to avoid potential conflicts
            qfSnapshot.forEach(documentSnapshot => knockoutMatches.quarter_finals.push(documentSnapshot.data())); 

            const sfSnapshot = await getDocs(collection(db, "knockoutMatches", "semi_finals", "matches"));
            // Renamed 'doc' to 'documentSnapshot' to avoid potential conflicts
            sfSnapshot.forEach(documentSnapshot => knockoutMatches.semi_finals.push(documentSnapshot.data()));
            
            const finalSnapshot = await getDocs(collection(db, "knockoutMatches", "final", "matches"));
            // Renamed 'doc' to 'documentSnapshot' to avoid potential conflicts
            finalSnapshot.forEach(documentSnapshot => knockoutMatches.final.push(documentSnapshot.data()));


            // --- Quarter Finals ---
            let qfHtml = "";
            const qfLabels = ["QF1", "QF2", "QF3", "QF4"];
            if (qualifiers.length >= 8) {
                // Pairings: Rank 1 vs 8, 4 vs 5, 2 vs 7, 3 vs 6
                const qfPairings = [
                    { teamA: qualifiers[0], teamB: qualifiers[7] },
                    { teamA: qualifiers[3], teamB: qualifiers[4] },
                    { teamA: qualifiers[1], teamB: qualifiers[6] },
                    { teamA: qualifiers[2], teamB: qualifiers[5] }
                ];

                qfPairings.forEach((pairing, index) => {
                    const label = qfLabels[index]; // Get the specific label
                    let score = "- (No Data)";
                    let venue = "TBD";
                    let time = "TBD";
                    
                    // Try to find actual match result
                    const matchData = knockoutMatches.quarter_finals.find(
                        m => (m.teamA === pairing.teamA.teamName && m.teamB === pairing.teamB.teamName) ||
                             (m.teamA === pairing.teamB.teamName && m.teamB === pairing.teamA.teamName)
                    );

                    if (matchData) {
                        const scoreA = parseInt(matchData.scoreA);
                        const scoreB = parseInt(matchData.scoreB);

                        if (!isNaN(scoreA) && !isNaN(scoreB)) {
                            score = `${scoreA} - ${scoreB}`;
                        }
                        venue = matchData.venue || "TBD";
                        time = matchData.time || "TBD";
                    }

                    qfHtml += `<div class="bracket-match">
                                    <p class="teams">${label}: ${pairing.teamA.teamName} vs ${pairing.teamB.teamName}</p>
                                    <p class="score">Score: ${score}</p>
                                    <p class="venue-time">Venue: ${venue}, Time: ${time}</p>
                                </div>`;
                });
            } else {
                // Generate default QF matches even if not enough qualifiers
                qfLabels.forEach(label => {
                    qfHtml += `<div class="bracket-match no-data-message">
                                <p class="teams">${label}: TBD vs TBD</p>
                                <p class="score">Score: - (Not enough qualifiers)</p>
                                <p class="venue-time">Venue: TBD, Time: TBD</p>
                            </div>`;
                });
                qfHtml += `<div class="bracket-match no-data-message" style="margin-top: 10px;"><p>Only ${qualifiers.length}/8 teams qualified so far.</p></div>`; // Consolidated message
            }
            document.getElementById('quarterFinals').innerHTML = qfHtml;

            // --- Semi Finals ---
            let sfHtml = "";
            const sfLabels = ["SF1", "SF2"];
            // Default Semi Final pairings if no actual data exists
            const defaultSfPairings = [
                { teamA: "Winner QF1", teamB: "Winner QF2" },
                { teamA: "Winner QF3", teamB: "Winner QF4" }
            ];

            // Ensure two match boxes are always rendered for Semi Finals
            const semiFinalDocs = [];
            knockoutMatches.semi_finals.forEach(matchData => semiFinalDocs.push(matchData)); // 'matchData' is already a plain object

            for (let i = 0; i < 2; i++) {
                const label = sfLabels[i];
                let teamA = "TBD";
                let teamB = "TBD";
                let score = "- (No Data)";
                let venue = "TBD";
                let time = "TBD";
                let isNoData = true; // Flag to apply no-data-message class

                if (semiFinalDocs[i]) { // Check if actual data exists for this SF match
                    const match = semiFinalDocs[i];
                    teamA = match.teamA || "TBD";
                    teamB = match.teamB || "TBD";
                    score = `${match.scoreA !== undefined ? match.scoreA : ''} - ${match.scoreB !== undefined ? match.scoreB : ''}`;
                    venue = match.venue || "TBD";
                    time = match.time || "TBD";
                    isNoData = false; // Data exists, so don't apply no-data-message
                } else {
                    // If actual data for this SF match is missing, use default winners
                    if (i === 0) { // SF1
                        teamA = defaultSfPairings[0].teamA;
                        teamB = defaultSfPairings[0].teamB;
                    } else if (i === 1) { // SF2
                        teamA = defaultSfPairings[1].teamA;
                        teamB = defaultSfPairings[1].teamB;
                    }
                }

                sfHtml += `<div class="bracket-match ${isNoData ? 'no-data-message' : ''}">
                                <p class="teams">${label}: ${teamA} vs ${teamB}</p>
                                <p class="score">Score: ${score}</p>
                                <p class="venue-time">Venue: ${venue}, Time: ${time}</p>
                            </div>`;
            }
            document.getElementById('semiFinals').innerHTML = sfHtml;

            // --- Final ---
            let finalHtml = "";
            const finalLabel = "Final"; // Label for the final match
            // Default Final pairing if no actual data exists
            const defaultFinalPairing = { teamA: "Winner SF1", teamB: "Winner SF2" };

            // Ensure one match box is always rendered for Final
            const finalDocs = [];
            knockoutMatches.final.forEach(matchData => finalDocs.push(matchData)); // 'matchData' is already a plain object

            let teamA_final = "TBD";
            let teamB_final = "TBD";
            let score_final = "- (No Data)";
            let venue_final = "TBD";
            let time_final = "TBD";
            let isFinalNoData = true;

            if (finalDocs[0]) { // Check if actual data exists for the Final match
                const match = finalDocs[0];
                teamA_final = match.teamA || "TBD";
                teamB_final = match.teamB || "TBD";
                score_final = `${match.scoreA !== undefined ? match.scoreA : ''} - ${match.scoreB !== undefined ? match.scoreB : ''}`;
                venue_final = match.venue || "TBD";
                time_final = match.time || "TBD";
                isFinalNoData = false;
            } else {
                // If actual data is missing, use default winners
                teamA_final = defaultFinalPairing.teamA;
                teamB_final = defaultFinalPairing.teamB;
            }

            finalHtml += `<div class="bracket-match ${isFinalNoData ? 'no-data-message' : ''}">
                            <p class="teams">${finalLabel}: ${teamA_final} vs ${teamB_final}</p>
                            <p class="score">Score: ${score_final}</p>
                            <p class="venue-time">Venue: ${venue_final}, Time: ${time_final}</p>
                        </div>`;
            
            document.getElementById('finalMatch').innerHTML = finalHtml;

        } catch (error) {
            console.error("Error fetching Next Stage data: ", error);
            document.getElementById('quarterFinals').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Quarter Final data.</p></div>`;
            document.getElementById('semiFinals').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Semi Final data.</p></div>`;
            document.getElementById('finalMatch').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Final data.</p></div>`;
        }
    }

    // Fetches and displays data for the Group Stage (tables and match details).
    window.fetchGroupStageData = async function() {
        try {
            const { standingsByGroup, matchesByGroup, teamsByGroup } = await window.getGroupStageData();

            let groupTablesHtml = "<h3>Group Stage Standings</h3>";
            for (const group of window.groups) {
                const sortedStandings = standingsByGroup[group] || [];
                const groupTeams = teamsByGroup[group] || [];

                if (sortedStandings.length > 0 || groupTeams.length > 0) {
                    groupTablesHtml += `<h4>Group ${group} Standings</h4>`;
                    groupTablesHtml += `<table class="group-standings-table">
                                        <thead>
                                            <tr>
                                                <th>Team</th>
                                                <th>Played</th>
                                                <th>Win</th>
                                                <th>Loss</th>
                                                <!-- 'Draw' column removed as requested -->
                                                <th>Points</th>
                                                <th>Score+</th>
                                                <th>Score-</th>
                                                <th>Diff</th>
                                            </tr>
                                        </thead>
                                        <tbody>`;
                    if (sortedStandings.length > 0) {
                        sortedStandings.forEach(team => {
                            groupTablesHtml += `<tr>
                                                    <td>${team.teamName || 'N/A'}</td>
                                                    <td>${team.played}</td>
                                                    <td>${team.wins}</td>
                                                    <td>${team.losses}</td>
                                                    <!-- 'Draw' value removed as requested -->
                                                    <td>${team.points}</td>
                                                    <td>${team.scoreFor}</td>
                                                    <td>${team.scoreAgainst}</td>
                                                    <td>${team.difference}</td>
                                                </tr>`;
                        });
                    } else if (groupTeams.length > 0) {
                         groupTeams.forEach(teamName => {
                             groupTablesHtml += `<tr>
                                                     <td>${teamName || 'N/A'}</td>
                                                     <td>0</td> <td>0</td> <td>0</td>
                                                     <td>0</td> <td>0</td> <td>0</td> <td>0</td>
                                                 </tr>`;
                         });
                    } else {
                         // Adjusted colspan from 9 to 8 because 'Draw' column is removed
                         groupTablesHtml += `<tr><td colspan="8">No teams registered for this group.</td></tr>`;
                    }
                    groupTablesHtml += `</tbody></table>`;
                } else {
                    groupTablesHtml += `<h4>Group ${group} Standings</h4><p>No teams registered for Group ${group}.</p>`;
                }
            }
            document.getElementById('groupTables').innerHTML = groupTablesHtml;


            // --- Match Details ---
            let matchMatrixHtml = "<h3>Group Stage Match Details</h3>";
            for (const group of window.groups) {
                const groupDocRef = doc(db, "matchResults", group);
                const groupDocSnap = await getDoc(groupDocRef);
                
                const groupTeams = teamsByGroup[group] || [];
                groupTeams.sort();

                matchMatrixHtml += `<h4>Group ${group}</h4>`;

                if (groupTeams.length > 0) {
                    const venue = groupDocSnap.exists() ? (groupDocSnap.data().venue || 'N/A') : 'N/A';
                    const time = groupDocSnap.exists() ? (groupDocSnap.data().time || 'N/A') : 'N/A';
                    matchMatrixHtml += `<div class="venue-time">Venue: ${venue}, Time: ${time}</div>`;

                    matchMatrixHtml += `<table class="match-matrix-table">
                                        <thead>
                                            <tr>
                                                <th></th>`;
                    groupTeams.forEach(team => {
                        matchMatrixHtml += `<th>${team}</th>`;
                    });
                    matchMatrixHtml += `</tr></thead><tbody>`; 
                    groupTeams.forEach(rowTeam => {
                        matchMatrixHtml += `<tr><th>${rowTeam}</th>`;
                        groupTeams.forEach(colTeam => {
                            if (rowTeam === colTeam) {
                                matchMatrixHtml += `<td class="empty-cell"></td>`;
                            } else {
                                let score = "-";
                                if (groupDocSnap.exists() && matchesByGroup[group]) {
                                    const matches = matchesByGroup[group];
                                    const key1 = `${rowTeam.replace(/\s/g, '_')}_vs_${colTeam.replace(/\s/g, '_')}`;
                                    const key2 = `${colTeam.replace(/\s/g, '_')}_vs_${rowTeam.replace(/\s/g, '_')}`;

                                    if (matches[key1]) {
                                        score = matches[key1];
                                    } else if (matches[key2]) {
                                        const parts = matches[key2].split('-');
                                        if (parts.length === 2) {
                                            score = `${parts[1]}-${parts[0]}`;
                                        } else {
                                            score = matches[key2];
                                        }
                                    }
                                }
                                matchMatrixHtml += `<td class="score-cell">${score}</td>`;
                            }
                        });
                        matchMatrixHtml += `</tr>`;
                    });
                    matchMatrixHtml += `</tbody></table>`;
                } else {
                    matchMatrixHtml += `<p>No teams registered for Group ${group}.</p>`;
                }
            }
            document.getElementById('matchMatrix').innerHTML = matchMatrixHtml;

        } catch (error) {
            console.error("Error fetching Group Stage data: ", error);
            document.getElementById('groupTables').innerHTML = "<p>Error loading group tables data.</p>";
            document.getElementById('matchMatrix').innerHTML = "<p>Error loading match details data.</p>";
        }
    }

    // New function to fetch and display all fixtures (without scores)
    window.fetchFixturesData = async function() {
        try {
            const { teamsByGroup } = await window.getGroupStageData(); // Get teams and group info

            // Fetch matchResults for venue/time, and knockoutMatches for teams in knockout stage
            const groupMatchResults = {};
            for (const group of window.groups) {
                const groupDocRef = doc(db, "matchResults", group);
                const groupDocSnap = await getDoc(groupDocRef);
                if (groupDocSnap.exists()) {
                    groupMatchResults[group] = groupDocSnap.data();
                } else {
                    groupMatchResults[group] = {}; // Ensure it's an object even if no data
                }
            }

            const knockoutMatchesData = {
                quarter_finals: [],
                semi_finals: [],
                final: []
            };
            const qfSnapshot = await getDocs(collection(db, "knockoutMatches", "quarter_finals", "matches"));
            qfSnapshot.forEach(documentSnapshot => knockoutMatchesData.quarter_finals.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'
            const sfSnapshot = await getDocs(collection(db, "knockoutMatches", "semi_finals", "matches"));
            sfSnapshot.forEach(documentSnapshot => knockoutMatchesData.semi_finals.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'
            const finalSnapshot = await getDocs(collection(db, "knockoutMatches", "final", "matches"));
            finalSnapshot.forEach(documentSnapshot => knockoutMatchesData.final.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'

            let fixturesHtml = `<table class="fixtures-table">
                                <thead>
                                    <tr>
                                        <th>Group</th>
                                        <th>Match</th>
                                        <th>Venue</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody>`;

            // --- Group Stage Fixtures ---
            for (const group of window.groups) {
                const groupTeams = teamsByGroup[group] || [];
                groupTeams.sort(); 
                const groupVenue = groupMatchResults[group].venue || 'TBD';
                const groupTime = groupMatchResults[group].time || 'TBD';

                if (groupTeams.length > 1) {
                    fixturesHtml += `<tr><td colspan="4" class="group-heading">Group ${group}</td></tr>`;
                    // Generate all possible match pairings within the group
                    for (let i = 0; i < groupTeams.length; i++) {
                        for (let j = i + 1; j < groupTeams.length; j++) {
                            const teamA = groupTeams[i];
                            const teamB = groupTeams[j];
                            
                            fixturesHtml += `<tr>
                                                <td>${group}</td>
                                                <td>${teamA} vs ${teamB}</td>
                                                <td>${groupVenue}</td>
                                                <td>${groupTime}</td>
                                            </tr>`;
                        }
                    }
                } else {
                    fixturesHtml += `<tr><td colspan="4" class="group-heading">Group ${group}</td></tr>`;
                    fixturesHtml += `<tr><td colspan="4">No scheduled matches for Group ${group} (not enough teams).</td></tr>`;
                }
            }

            // --- Knockout Stage Fixtures ---
            fixturesHtml += `<tr><td colspan="4" class="group-heading" style="text-align: center;">KNOCKOUT STAGE</td></tr>`;

            // Quarter Finals
            fixturesHtml += `<tr><td colspan="4" class="group-heading">Quarter Finals</td></tr>`;
            const qfLabels = ["QF1", "QF2", "QF3", "QF4"];
            qfLabels.forEach((label, index) => {
                let teamA = "TBD";
                let teamB = "TBD";
                let venue = "TBD";
                let time = "TBD";

                if (knockoutMatchesData.quarter_finals[index]) {
                    teamA = knockoutMatchesData.quarter_finals[index].teamA || 'TBD';
                    teamB = knockoutMatchesData.quarter_finals[index].teamB || 'TBD';
                    venue = knockoutMatchesData.quarter_finals[index].venue || 'TBD';
                    time = knockoutMatchesData.quarter_finals[index].time || 'TBD';
                }
                fixturesHtml += `<tr>
                                    <td>N/A</td>
                                    <td>${label}: ${teamA} vs ${teamB}</td>
                                    <td>${venue}</td>
                                    <td>${time}</td>
                                </tr>`;
            });
           
            // Semi Finals
            fixturesHtml += `<tr><td colspan="4" class="group-heading">Semi Finals</td></tr>`;
            const sfLabels = ["SF1", "SF2"];
            sfLabels.forEach((label, index) => {
                let teamA = "Winner QF" + (index * 2 + 1);
                let teamB = "Winner QF" + (index * 2 + 2);
                let venue = "TBD";
                let time = "TBD";

                if (knockoutMatchesData.semi_finals[index]) {
                    teamA = knockoutMatchesData.semi_finals[index].teamA || teamA;
                    teamB = knockoutMatchesData.semi_finals[index].teamB || teamB;
                    venue = knockoutMatchesData.semi_finals[index].venue || 'TBD';
                    time = knockoutMatchesData.semi_finals[index].time || 'TBD';
                }
                fixturesHtml += `<tr>
                                    <td>N/A</td>
                                    <td>${label}: ${teamA} vs ${teamB}</td>
                                    <td>${venue}</td>
                                    <td>${time}</td>
                                </tr>`;
            });

            // Final
            fixturesHtml += `<tr><td colspan="4" class="group-heading">Final</td></tr>`;
            let finalTeamA = "Winner SF1";
            let finalTeamB = "Winner SF2";
            let finalVenue = "TBD";
            let finalTime = "TBD";

            if (knockoutMatchesData.final[0]) {
                finalTeamA = knockoutMatchesData.final[0].teamA || finalTeamA;
                finalTeamB = knockoutMatchesData.final[0].teamB || finalTeamB;
                finalVenue = knockoutMatchesData.final[0].venue || 'TBD';
                finalTime = knockoutMatchesData.final[0].time || 'TBD';
            }
            fixturesHtml += `<tr>
                                <td>N/A</td>
                                <td>Final: ${finalTeamA} vs ${finalTeamB}</td>
                                <td>${finalVenue}</td>
                                <td>${finalTime}</td>
                            </tr>`;

            fixturesHtml += `</tbody></table>`;
            document.getElementById('fixturesContent').innerHTML = fixturesHtml;

        } catch (error) {
            console.error("Error fetching fixtures data:", error);
            document.getElementById('fixturesContent').innerHTML = "<p>Error loading fixtures data.</p>";
        }
    }

    // Call fetch functions when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        window.switchTab('groupStage'); 
        console.log("Fetching Next Stage data...");
        window.fetchNextStageData(); 
        console.log("Fetching Group Stage data...");
        window.fetchGroupStageData();
        console.log("Fetching Fixtures data...");
        window.fetchFixturesData(); // Call new fixtures function
    });
  </script>

  <!-- jsPDF and jspdf-autotable CDN. Moved outside the module script to ensure global availability -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

  <script> // This script is NOT a module
    // Global function to download results as PDF
    window.downloadResultsPdf = async function() {
        console.log("Attempting to download Results PDF...");
        
        let jsPDFConstructor;
        // Check for the jsPDF constructor in the global scope
        if (typeof window.jsPDF === 'function') { // This is the most direct way jsPDF might expose itself globally
            jsPDFConstructor = window.jsPDF;
            console.log("Constructor found at window.jsPDF. Type:", typeof jsPDFConstructor);
        } else if (typeof window.jspdf !== 'undefined' && typeof window.jspdf.jsPDF === 'function') {
            jsPDFConstructor = window.jspdf.jsPDF;
            console.log("Constructor found at window.jspdf.jsPDF. Type:", typeof jsPDFConstructor);
        } else if (typeof window.jspdf === 'function') { 
            jsPDFConstructor = window.jspdf;
            console.log("Constructor found at window.jspdf (fallback). Type:", typeof jsPDFConstructor);
        }
        
        if (typeof jsPDFConstructor !== 'function') {
            console.error("jsPDF constructor not found or is not a function after all checks. PDF generation aborted. Final value:", jsPDFConstructor);
            alert("Error: PDF library not loaded correctly. Please try again.");
            return;
        }

        try {
            console.log("Attempting to create new jsPDF instance with constructor. Type:", typeof jsPDFConstructor, "Is function:", typeof jsPDFConstructor === 'function');
            const pdfDoc = new jsPDFConstructor(); 
            console.log("jsPDF instance created successfully.");

            let yOffset = 10; // Initial Y offset for content

            pdfDoc.setFontSize(22); 
            pdfDoc.text("SMZ18201: Petanque Match Results", pdfDoc.internal.pageSize.width / 2, yOffset, { align: 'center' }); 
            yOffset += 15;

            console.log("Fetching group stage and knockout data for PDF...");
            // These functions are defined in the module script. Access them via window.
            const { standingsByGroup, matchesByGroup, teamsByGroup } = await window.getGroupStageData();
            
            const knockoutMatches = {
                quarter_finals: [],
                semi_finals: [],
                final: []
            };

            const qfSnapshot = await window.getDocs(window.collection(window.db, "knockoutMatches", "quarter_finals", "matches"));
            qfSnapshot.forEach(documentSnapshot => knockoutMatches.quarter_finals.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'

            const sfSnapshot = await window.getDocs(window.collection(window.db, "knockoutMatches", "semi_finals", "matches"));
            sfSnapshot.forEach(documentSnapshot => knockoutMatches.semi_finals.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'
            
            const finalSnapshot = await window.getDocs(window.collection(window.db, "knockoutMatches", "final", "matches"));
            finalSnapshot.forEach(documentSnapshot => knockoutMatches.final.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'
            console.log("Data fetched for PDF.");
            
            // --- Group Stage Standings ---
            yOffset += 10;
            pdfDoc.setFontSize(18); 
            pdfDoc.text("Group Stage Standings", pdfDoc.internal.pageSize.width / 2, yOffset, { align: 'center' }); 
            yOffset += 10;

            for (const group of window.groups) { 
                const sortedStandings = standingsByGroup[group] || [];
                
                if (sortedStandings.length > 0) {
                    pdfDoc.setFontSize(14); 
                    pdfDoc.text(`Group ${group} Standings`, 14, yOffset); 
                    yOffset += 8;

                    // Removed "Draw" from headers for results PDF as requested
                    const headers = ["Team", "Played", "Win", "Loss", "Points", "Score+", "Score-", "Diff"];
                    const data = sortedStandings.map(team => [
                        team.teamName || 'N/A',
                        team.played,
                        team.wins,
                        team.losses,
                        // Removed team.draws from data mapping
                        team.points,
                        team.scoreFor,
                        team.scoreAgainst,
                        team.difference
                    ]);

                    console.log(`Adding Group ${group} Standings to PDF. Headers:`, headers, "Data:", data);
                    pdfDoc.autoTable({ 
                        startY: yOffset,
                        head: [headers],
                        body: data,
                        headStyles: { fillColor: [0, 123, 255], textColor: 255, fontStyle: 'bold' },
                        styles: { fontSize: 8, cellPadding: 2, textColor: [52, 58, 64] },
                        alternateRowStyles: { fillColor: [248, 249, 250] },
                        margin: { left: 14, right: 14 }
                    });
                    yOffset = pdfDoc.autoTable.previous.finalY + 10; 
                } else {
                    pdfDoc.setFontSize(12); 
                    pdfDoc.text(`Group ${group} Standings: No teams registered.`, 14, yOffset); 
                    yOffset += 10;
                }
            }

            // --- Group Stage Match Details ---
            yOffset += 10;
            // Check if there's enough space, otherwise add a new page
            if (yOffset + 50 > pdfDoc.internal.pageSize.height - 20) { 
                pdfDoc.addPage(); 
                yOffset = 20;
            }
            pdfDoc.setFontSize(18); 
            pdfDoc.text("Group Stage Match Details", pdfDoc.internal.pageSize.width / 2, yOffset, { align: 'center' }); 
            yOffset += 10;

            for (const group of window.groups) { 
                const currentGroupMatches = matchesByGroup[group] || {};
                const groupTeams = teamsByGroup[group] || [];
                groupTeams.sort();

                // Check if there's enough space for the next group's matches
                if (yOffset + 30 > pdfDoc.internal.pageSize.height - 20 && group !== window.groups[0]) { 
                    pdfDoc.addPage(); 
                    yOffset = 20;
                }

                pdfDoc.setFontSize(14); 
                pdfDoc.text(`Group ${group} Matches`, 14, yOffset); 
                yOffset += 8;

                const matchDetailsData = [];
                const groupDocRef = window.doc(window.db, "matchResults", group); 
                const groupDocSnap = await window.getDoc(groupDocRef); 
                const venue = groupDocSnap.exists() ? (groupDocSnap.data().venue || 'N/A') : 'N/A';
                const time = groupDocSnap.exists() ? (groupDocSnap.data().time || 'N/A') : 'N/A';
                matchDetailsData.push([{ content: `Venue: ${venue}, Time: ${time}`, colSpan: 2, styles: { fontStyle: 'italic', fontSize: 9, textColor: [108, 117, 125] } }]);


                let hasMatches = false;
                if (groupTeams.length > 1) {
                    for (let i = 0; i < groupTeams.length; i++) {
                        for (let j = i + 1; j < groupTeams.length; j++) {
                            const teamA = groupTeams[i];
                            const teamB = groupTeams[j];
                            const key1 = `${teamA.replace(/\s/g, '_')}_vs_${teamB.replace(/\s/g, '_')}`;
                            const key2 = `${teamB.replace(/\s/g, '_')}_vs_${teamA.replace(/\s/g, '_')}`;

                            let score = "- (No Score)";
                            if (currentGroupMatches[key1]) {
                                score = currentGroupMatches[key1];
                                hasMatches = true;
                            } else if (currentGroupMatches[key2]) {
                                const parts = currentGroupMatches[key2].split('-');
                                if (parts.length === 2) {
                                    score = `${parts[1]}-${parts[0]}`;
                                } else {
                                    score = currentGroupMatches[key2];
                                }
                                hasMatches = true;
                            }
                            matchDetailsData.push([`${teamA} vs ${teamB}`, score]);
                        }
                    }
                }
                
                if (!hasMatches && groupTeams.length <= 1) {
                    matchDetailsData.push([{ content: "Not enough teams for matches in this group.", colSpan: 2, styles: { textColor: [150, 150, 150] } }]);
                } else if (!hasMatches && groupTeams.length > 1) {
                     matchDetailsData.push([{ content: "No matches recorded for this group yet.", colSpan: 2, styles: { textColor: [150, 150, 150] } }]);
                }
                
                console.log(`Adding Group ${group} Match Details to PDF. Headers: [Match, Score], Data:`, matchDetailsData);
                pdfDoc.autoTable({ 
                    startY: yOffset,
                    head: [["Match", "Score"]],
                    body: matchDetailsData,
                    headStyles: { fillColor: [0, 123, 255], textColor: 255, fontStyle: 'bold' },
                    styles: { fontSize: 8, cellPadding: 2, textColor: [52, 58, 64] },
                    alternateRowStyles: { fillColor: [248, 249, 250] },
                    margin: { left: 14, right: 14 }
                });
                yOffset = pdfDoc.autoTable.previous.finalY + 10; 
            }

            // --- Knockout Stage ---
            yOffset += 10;
            // Check if there's enough space, otherwise add a new page
            if (yOffset + 50 > pdfDoc.internal.pageSize.height - 20) { 
                pdfDoc.addPage(); 
                yOffset = 20;
            }
            pdfDoc.setFontSize(18); 
            pdfDoc.text("Knockout Stage", pdfDoc.internal.pageSize.width / 2, yOffset, { align: 'center' }); 
            yOffset += 10;

            const knockoutStages = {
                "Quarter Final": knockoutMatches.quarter_finals,
                "Semi Final": knockoutMatches.semi_finals,
                "Final": knockoutMatches.final
            };

            for (const stageLabel in knockoutStages) {
                // Check if there's enough space for the next stage
                if (yOffset + 30 > pdfDoc.internal.pageSize.height - 20 && stageLabel !== "Quarter Final") { 
                    pdfDoc.addPage(); 
                    yOffset = 20;
                }

                pdfDoc.setFontSize(14); 
                pdfDoc.text(stageLabel, 14, yOffset); 
                yOffset += 8;

                const knockoutData = [];
                let hasKnockoutMatches = false;

                knockoutStages[stageLabel].forEach(match => {
                    const teamA = match.teamA || 'TBD';
                    const teamB = match.teamB || 'TBD';
                    const score = (match.scoreA !== undefined && match.scoreB !== undefined) ? `${match.scoreA} - ${match.scoreB}` : "-";
                    const venue = match.venue || 'TBD';
                    const time = match.time || 'TBD';
                    knockoutData.push([`${teamA} vs ${teamB}`, score, `${venue}, ${time}`]);
                    hasKnockoutMatches = true;
                });
                
                // Fallback for PDF generation if no actual data exists
                if (!hasKnockoutMatches) {
                    if (stageLabel === "Quarter Final") {
                        knockoutData.push(["QF1: TBD vs TBD", "- (No Data)", "Venue: TBD, Time: TBD"]);
                        knockoutData.push(["QF2: TBD vs TBD", "- (No Data)", "Venue: TBD, Time: TBD"]);
                        knockoutData.push(["QF3: TBD vs TBD", "- (No Data)", "Venue: TBD, Time: TBD"]);
                        knockoutData.push(["QF4: TBD vs TBD", "- (No Data)", "Venue: TBD, Time: TBD"]);
                    } else if (stageLabel === "Semi Final") {
                         knockoutData.push(["SF1: Winner QF1 vs Winner QF2", "- (No Data)", "Venue: TBD, Time: TBD"]);
                         knockoutData.push(["SF2: Winner QF3 vs Winner QF4", "- (No Data)", "Venue: TBD, Time: TBD"]);
                    } else if (stageLabel === "Final") {
                         knockoutData.push(["Final: Winner SF1 vs Winner SF2", "- (No Data)", "Venue: TBD, Time: TBD"]);
                    }
                }

                console.log(`Adding ${stageLabel} to PDF. Headers: [Match, Score, Venue & Time], Data:`, knockoutData);
                pdfDoc.autoTable({ 
                    startY: yOffset,
                    head: [["Match", "Score", "Venue & Time"]],
                    body: knockoutData,
                    headStyles: { fillColor: [0, 123, 255], textColor: 255, fontStyle: 'bold' },
                    styles: { fontSize: 8, cellPadding: 2, textColor: [52, 58, 64] },
                    alternateRowStyles: { fillColor: [248, 249, 250] },
                    margin: { left: 14, right: 14 }
                });
                yOffset = pdfDoc.autoTable.previous.finalY + 10; 
            }

            console.log("Saving PDF...");
            pdfDoc.save('Petanque_Results.pdf'); 
            alert("PDF generated successfully!");
            console.log("PDF generation process completed.");
        } catch (error) {
            console.error("Error during PDF generation:", error);
            alert("An error occurred while generating the PDF. Please check the console for details.");
        }
    };

    // Global function to download fixtures as PDF
    window.downloadFixturesPdf = async function() {
        console.log("Attempting to download Fixtures PDF...");

        let jsPDFConstructor;
        if (typeof window.jsPDF === 'function') {
            jsPDFConstructor = window.jsPDF;
        } else if (typeof window.jspdf !== 'undefined' && typeof window.jspdf.jsPDF === 'function') {
            jsPDFConstructor = window.jspdf.jsPDF;
        } else if (typeof window.jspdf === 'function') {
            jsPDFConstructor = window.jspdf;
        }
        
        if (typeof jsPDFConstructor !== 'function') {
            console.error("jsPDF constructor not found or is not a function. PDF generation aborted.");
            alert("Error: PDF library not loaded correctly. Please try again.");
            return;
        }

        try {
            const pdfDoc = new jsPDFConstructor();
            let yOffset = 10;

            pdfDoc.setFontSize(22);
            pdfDoc.text("SMZ18201: Petanque Match Fixtures", pdfDoc.internal.pageSize.width / 2, yOffset, { align: 'center' });
            yOffset += 15;

            const { teamsByGroup } = await window.getGroupStageData();
            
            // Fetch matchResults for venue/time, and knockoutMatches for teams in knockout stage
            const groupMatchResults = {};
            for (const group of window.groups) {
                const groupDocRef = doc(db, "matchResults", group);
                const groupDocSnap = await getDoc(groupDocRef);
                if (groupDocSnap.exists()) {
                    groupMatchResults[group] = groupDocSnap.data();
                } else {
                    groupMatchResults[group] = {};
                }
            }

            const knockoutMatchesData = {
                quarter_finals: [],
                semi_finals: [],
                final: []
            };
            const qfSnapshot = await getDocs(collection(db, "knockoutMatches", "quarter_finals", "matches"));
            qfSnapshot.forEach(documentSnapshot => knockoutMatchesData.quarter_finals.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'
            const sfSnapshot = await getDocs(collection(db, "knockoutMatches", "semi_finals", "matches"));
            sfSnapshot.forEach(documentSnapshot => knockoutMatchesData.semi_finals.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'
            const finalSnapshot = await getDocs(collection(db, "knockoutMatches", "final", "matches"));
            finalSnapshot.forEach(documentSnapshot => knockoutMatchesData.final.push(documentSnapshot.data())); // Renamed 'doc' to 'documentSnapshot'

            const fixturesData = [];

            // --- Group Stage Fixtures ---
            for (const group of window.groups) {
                const groupTeams = teamsByGroup[group] || [];
                groupTeams.sort(); 
                const groupVenue = groupMatchResults[group].venue || 'TBD';
                const groupTime = groupMatchResults[group].time || 'TBD';

                if (groupTeams.length > 1) {
                    fixturesData.push([{ content: `Group ${group}`, colSpan: 4, styles: { fillColor: [209, 236, 241], textColor: [12, 84, 96], fontStyle: 'bold', halign: 'left' } }]);
                    // Generate all possible match pairings within the group
                    for (let i = 0; i < groupTeams.length; i++) {
                        for (let j = i + 1; j < groupTeams.length; j++) {
                            const teamA = groupTeams[i];
                            const teamB = groupTeams[j];
                            
                            fixturesData.push([group, `${teamA} vs ${teamB}`, groupVenue, groupTime]);
                        }
                    }
                } else {
                    fixturesData.push([{ content: `Group ${group}: No scheduled matches (not enough teams).`, colSpan: 4, styles: { fillColor: [248, 249, 250], textColor: [150, 150, 150], fontStyle: 'italic', halign: 'left' } }]);
                }
            }

            // --- Knockout Stage Fixtures ---
            fixturesData.push([{ content: "KNOCKOUT STAGE", colSpan: 4, styles: { fillColor: [209, 236, 241], textColor: [12, 84, 96], fontStyle: 'bold', halign: 'center' } }]);

            // Quarter Finals
            fixturesData.push([{ content: "Quarter Finals", colSpan: 4, styles: { fillColor: [209, 236, 241], textColor: [12, 84, 96], fontStyle: 'bold', halign: 'left' } }]);
            const qfLabels = ["QF1", "QF2", "QF3", "QF4"];
            qfLabels.forEach((label, index) => {
                let teamA = "TBD";
                let teamB = "TBD";
                let venue = "TBD";
                let time = "TBD";

                if (knockoutMatchesData.quarter_finals[index]) {
                    teamA = knockoutMatchesData.quarter_finals[index].teamA || 'TBD';
                    teamB = knockoutMatchesData.quarter_finals[index].teamB || 'TBD';
                    venue = knockoutMatchesData.quarter_finals[index].venue || 'TBD';
                    time = knockoutMatchesData.quarter_finals[index].time || 'TBD';
                }
                fixturesData.push(['N/A', `${label}: ${teamA} vs ${teamB}`, venue, time]);
            });
           
            // Semi Finals
            fixturesData.push([{ content: "Semi Finals", colSpan: 4, styles: { fillColor: [209, 236, 241], textColor: [12, 84, 96], fontStyle: 'bold', halign: 'left' } }]);
            const sfLabels = ["SF1", "SF2"];
            sfLabels.forEach((label, index) => {
                let teamA = "Winner QF" + (index * 2 + 1);
                let teamB = "Winner QF" + (index * 2 + 2);
                let venue = "TBD";
                let time = "TBD";

                if (knockoutMatchesData.semi_finals[index]) {
                    teamA = knockoutMatchesData.semi_finals[index].teamA || teamA;
                    teamB = knockoutMatchesData.semi_finals[index].teamB || teamB;
                    venue = knockoutMatchesData.semi_finals[index].venue || 'TBD';
                    time = knockoutMatchesData.semi_finals[index].time || 'TBD';
                }
                fixturesData.push(['N/A', `${label}: ${teamA} vs ${teamB}`, venue, time]);
            });

            // Final
            fixturesData.push([{ content: "Final", colSpan: 4, styles: { fillColor: [209, 236, 241], textColor: [12, 84, 96], fontStyle: 'bold', halign: 'left' } }]);
            let finalTeamA = "Winner SF1";
            let finalTeamB = "Winner SF2";
            let finalVenue = "TBD";
            let finalTime = "TBD";

            if (knockoutMatchesData.final[0]) {
                finalTeamA = knockoutMatchesData.final[0].teamA || finalTeamA;
                finalTeamB = knockoutMatchesData.final[0].teamB || finalTeamB;
                finalVenue = knockoutMatchesData.final[0].venue || 'TBD';
                finalTime = knockoutMatchesData.final[0].time || 'TBD';
            }
            fixturesData.push(['N/A', `Final: ${finalTeamA} vs ${finalTeamB}`, finalVenue, finalTime]);

            pdfDoc.autoTable({
                startY: yOffset + 5,
                head: [["Group", "Match", "Venue", "Time"]],
                body: fixturesData,
                headStyles: { fillColor: [0, 123, 255], textColor: 255, fontStyle: 'bold' },
                styles: { fontSize: 8, cellPadding: 2, textColor: [52, 58, 64] },
                alternateRowStyles: { fillColor: [248, 249, 250] },
                margin: { left: 14, right: 14 },
                didDrawPage: function (data) { // Add page numbers
                    pdfDoc.setFontSize(8);
                    pdfDoc.text('Page ' + pdfDoc.internal.getNumberOfPages(), data.settings.margin.left, pdfDoc.internal.pageSize.height - 10);
                }
            });

            console.log("Saving Fixtures PDF...");
            pdfDoc.save('Petanque_Fixtures.pdf');
            alert("Fixtures PDF generated successfully!");
            console.log("Fixtures PDF generation process completed.");

        } catch (error) {
            console.error("Error during Fixtures PDF generation:", error);
            alert("An error occurred while generating the Fixtures PDF. Please check the console for details.");
        }
    };
  </script>
</body>
</html>
