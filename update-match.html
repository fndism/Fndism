<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Update Petanque Results</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f9fa;
      padding: 20px;
      min-height: 100vh; /* Ensure body takes full viewport height for footer positioning */
      display: flex;
      flex-direction: column;
    }
    h1 {
      text-align: center;
      color: #343a40;
      margin-bottom: 30px;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center; /* Center the tabs */
    }
    .tab {
      padding: 10px 20px;
      background: #007bff;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s ease;
    }
    .tab:hover {
      background: #0056b3;
    }
    .tab.active {
      background: #0056b3;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .tab-content {
      display: none;
      padding: 15px;
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      flex-grow: 1;
    }
    .tab-content.active {
      display: block;
    }
    h2 {
      color: #007bff;
      border-bottom: 2px solid #007bff;
      padding-bottom: 5px;
      margin-top: 25px;
      margin-bottom: 15px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    th, td {
      border: 1px solid #ccc;
      text-align: center;
      padding: 10px;
    }
    th {
      background: #e9ecef;
      color: #343a40;
      font-weight: bold;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    .match-matrix-table td.empty-cell {
        background-color: #eee;
    }
    .match-matrix-table td.score-cell {
        font-weight: bold;
        color: #0056b3;
    }

    /* Input styling for scores */
    .score-input {
        width: 60px;
        text-align: center;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 5px;
        margin: 0 5px;
    }
    .text-input { /* Style for venue/time inputs */
        width: 100px;
        text-align: center;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 5px;
        margin: 0 5px;
    }
    .save-button {
        background-color: #28a745;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        margin-left: 10px;
        transition: background-color 0.3s ease;
    }
    .save-button:hover {
        background-color: #218838;
    }
    .match-edit-controls {
        margin-top: 10px;
        text-align: right; /* For overall group save button */
    }
    .group-info-inputs {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
        justify-content: flex-start; /* Aligned to left */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }
    .group-info-inputs label {
        font-weight: bold;
        color: #555;
    }


    /* --- Knockout Bracket Styling --- */
    .tournament-bracket {
        display: grid;
        grid-template-columns: repeat(3, 1fr); /* QF, SF, Final */
        gap: 10px;
        max-width: 900px; /* Max width for the bracket */
        margin: 20px auto;
        padding: 20px;
        background: #fdfdfd;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        text-align: center;
    }
    .bracket-stage {
        display: flex;
        flex-direction: column;
        justify-content: space-around; /* Distribute matches evenly by default */
        padding: 10px 0;
    }
    .bracket-stage.quarter-finals-stage {
        grid-column: 1 / 2; /* First column */
    }
    .bracket-stage.semi-finals-stage {
        grid-column: 2 / 3; /* Second column */
        justify-content: center; /* ALIGNMENT FIX: Center content vertically for semi-finals */
    }
    .bracket-stage.final-stage {
        grid-column: 3 / 4; /* Third column */
        justify-content: center; /* Center the final match */
    }

    .bracket-match {
        background: #e9f5ff; /* Light blue for match boxes */
        border: 1px solid #cceeff;
        border-radius: 8px;
        padding: 10px;
        margin: 10px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        position: relative; /* For connecting lines */
        min-height: 80px; /* Ensure consistent height */
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .bracket-match .teams {
        font-weight: bold;
        color: #333;
        font-size: 0.95em;
    }
    .bracket-match .score {
      font-weight: bold;
      color: #dc3545;
      font-size: 0.9em;
      margin-top: 5px;
      display: flex; /* Use flexbox for score and inputs */
      justify-content: center;
      align-items: center;
    }
    .bracket-match .venue-time {
        font-size: 0.8em;
        color: #666;
        margin-top: 5px;
        display: flex; /* Use flexbox for venue/time and inputs */
        justify-content: center;
        align-items: center;
    }

    /* Connecting Lines (simplified for responsiveness) */
    .bracket-match::after {
        content: '';
        position: absolute;
        top: 50%;
        right: -10px; /* Half of gap */
        width: 10px; /* Half of gap */
        height: 1px;
        background: #999;
        transform: translateY(-50%);
    }

    /* SF to Final (more complex, needs specific styling for SF matches) */
    .bracket-stage.quarter-finals-stage .bracket-match:nth-child(odd)::before {
        content: '';
        position: absolute;
        top: 0;
        right: -30px; /* Extend into the gap */
        width: 20px;
        height: 50%;
        border-right: 1px solid #999;
        border-top: 1px solid #999;
    }
    .bracket-stage.quarter-finals-stage .bracket-match:nth-child(even)::before {
        content: '';
        position: absolute;
        bottom: 0;
        right: -30px; /* Extend into the gap */
        width: 20px;
        height: 50%;
        border-right: 1px solid #999;
        border-bottom: 1px solid #999;
    }
    .bracket-stage.quarter-finals-stage .bracket-match:nth-child(odd) + .bracket-match::before {
        top: 0; /* Reset for the even match following an odd one */
    }

    /* Basic lines for QF to SF */
    .quarter-finals-stage .bracket-match::after { /* Line from QF match to right */
        content: '';
        position: absolute;
        top: 50%;
        right: -5px; /* Connects to the next stage container boundary */
        width: 5px;
        height: 1px;
        background: #999;
        transform: translateY(-50%);
        z-index: 1;
    }

    /* Simple lines to represent connection. Full dynamic lines are very complex with pure CSS. */
    .semi-finals-stage .bracket-match::after {
        content: '';
        position: absolute;
        top: 50%;
        right: -5px;
        width: 5px;
        height: 1px;
        background: #999;
        transform: translateY(-50%);
        z-index: 1;
    }

    /* Vertical connector for SF to Final */
    .semi-finals-stage .bracket-match:first-child::before {
        content: '';
        position: absolute;
        bottom: -15px; /* Adjust based on match spacing */
        left: 50%;
        width: 1px;
        height: 30px; /* Length of vertical line */
        background: #999;
        transform: translateX(-50%);
        z-index: 0;
    }
    
    /* Hide lines for placeholder/empty messages */
    .bracket-match.no-data-message::after,
    .bracket-match.no-data-message::before {
        display: none;
    }

    @media (max-width: 768px) {
        .tournament-bracket {
            grid-template-columns: 1fr; /* Stack columns on smaller screens */
            gap: 5px; /* Reduced gap for smaller screens */
            padding: 10px; /* Reduced padding */
        }
        .bracket-stage {
            border-bottom: 1px solid #eee; /* Separate stages */
            margin-bottom: 5px; /* Reduced margin */
        }
        .bracket-stage:last-child {
            border-bottom: none;
        }
        .bracket-match {
            padding: 8px; /* Reduced padding inside match boxes */
            margin: 5px 0; /* Reduced margin between matches */
            min-height: auto; /* Allow height to adjust automatically */
        }
        .bracket-match .score .score-input {
            width: calc(50% - 10px); /* Adjusted width to fit two inputs side by side on mobile */
            margin: 0 2px; /* Reduce margin around score inputs */
        }
        .bracket-match .venue-time .text-input {
            width: calc(50% - 25px); /* Adjusted width to fit two inputs + labels on one line */
            margin: 0 2px; /* Reduce margin around text inputs */
        }
        .bracket-match::after,
        .bracket-match::before,
        .semi-finals-stage .bracket-match::before {
            display: none; /* Hide lines on mobile */
        }
        .group-info-inputs {
            flex-direction: column;
            align-items: flex-start;
        }
        .group-info-inputs label {
            margin-bottom: 5px;
        }
        .group-info-inputs .text-input {
            width: calc(100% - 10px); /* Adjust width for full mobile width */
        }
    }

    /* Footer styling */
    .footer {
        margin-top: auto; /* Push footer to the bottom */
        padding-top: 20px;
        text-align: center;
        font-size: 0.9em;
        color: #777;
    }
    /* Reset Button Styling */
    .reset-button-container {
        text-align: center;
        margin-top: 40px; /* More space from content above */
        padding-bottom: 20px; /* Space above footer */
    }
    .reset-button {
        background-color: #dc3545; /* Red color for reset */
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 8px;
        font-size: 1.1em;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.2s ease;
    }
    .reset-button:hover {
        background-color: #c82333; /* Darker red on hover */
        transform: scale(1.05);
    }
    .reset-message {
        margin-top: 15px;
        font-weight: bold;
        color: #dc3545; /* Red for warnings/status */
    }

    /* --- Custom Modal Styles --- */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000; /* Ensure it's on top */
        visibility: hidden; /* Hidden by default */
        opacity: 0;
        transition: visibility 0s, opacity 0.3s linear;
    }
    .modal-overlay.visible {
        visibility: visible;
        opacity: 1;
    }
    .modal-content {
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        text-align: center;
        max-width: 400px;
        width: 90%;
        transform: translateY(-20px);
        transition: transform 0.3s ease-out;
    }
    .modal-overlay.visible .modal-content {
        transform: translateY(0);
    }
    .modal-content h3 {
        margin-top: 0;
        color: #333;
        font-size: 1.3em;
    }
    .modal-content p {
        margin-bottom: 20px;
        color: #555;
    }
    .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 15px;
    }
    .modal-buttons button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s ease;
        margin-top: 0; /* Override default button margin */
    }
    .modal-buttons .confirm-btn {
        background-color: #dc3545; /* Red for confirm */
        color: white;
    }
    .modal-buttons .confirm-btn:hover {
        background-color: #c82333;
    }
    .modal-buttons .cancel-btn {
        background-color: #6c757d; /* Grey for cancel */
        color: white;
    }
    .modal-buttons .cancel-btn:hover {
        background-color: #5a6268;
    }

    /* Styling for the custom alert modal */
    .custom-alert-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001; /* Higher z-index than confirm modal */
        visibility: hidden;
        opacity: 0;
        transition: visibility 0s, opacity 0.3s linear;
    }
    .custom-alert-overlay.visible {
        visibility: visible;
        opacity: 1;
    }
    .custom-alert-content {
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        text-align: center;
        max-width: 350px;
        width: 80%;
        transform: translateY(-20px);
        transition: transform 0.3s ease-out;
    }
    .custom-alert-overlay.visible .custom-alert-content {
        transform: translateY(0);
    }
    .custom-alert-content p {
        margin-bottom: 20px;
        font-size: 1.1em;
        color: #333;
    }
    .custom-alert-content button {
        background-color: #007bff;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s ease;
        margin-top: 0;
    }
    .custom-alert-content button:hover {
        background-color: #0056b3;
    }
  </style>
</head>
<body>
  <h1>SMZ18201: Petanque Match Results (Update)</h1>

  <div class="tabs">
    <div class="tab active" onclick="window.switchTab('groupStage')">Group Stage</div>
    <div class="tab" onclick="window.switchTab('nextStage')">Next Stage</div>
    <div class="tab" onclick="window.location.href='admin.html'">â¬… Back</div>
  </div>

  <!-- Group Stage Content - now active by default -->
  <div id="groupStage" class="tab-content active">
    <h2>Match Details</h2>
    <div id="matchMatrix">Loading match details...</div>
  </div>

  <!-- Next Stage Content - now inactive by default -->
  <div id="nextStage" class="tab-content">
    <!-- Tournament Bracket Container -->
    <div class="tournament-bracket">
        <div class="bracket-stage quarter-finals-stage">
            <h2>Quarter Final</h2>
            <div id="quarterFinals">Loading Quarter Final matches...</div>
        </div>

        <div class="bracket-stage semi-finals-stage">
            <h2>Semi Final</h2>
            <div id="semiFinals">Loading Semi Final matches...</div>
        </div>

        <div class="bracket-stage final-stage">
            <h2>Final</h2>
            <div id="finalMatch">Loading Final match...</div>
        
        </div>
    </div>
  </div>

  <!-- Reset Button Section -->
  <div class="reset-button-container">
    <button class="reset-button" onclick="window.resetGameData()">Reset All Match Data</button>
    <div id="resetStatus" class="reset-message"></div>
  </div>

  <div class="footer">
    <p>&copy; 2025 Fndism. All rights reserved.</p>
  </div>

  <!-- Custom Confirmation Modal -->
  <div class="modal-overlay" id="confirmModalOverlay">
      <div class="modal-content">
          <h3 id="confirmModalTitle">Confirm Action</h3>
          <p id="confirmModalMessage">Are you sure you want to proceed?</p>
          <div class="modal-buttons">
              <button class="confirm-btn" id="confirmModalConfirmBtn">Yes</button>
              <button class="cancel-btn" id="confirmModalCancelBtn">No</button>
          </div>
      </div>
  </div>

  <!-- Custom Alert Modal -->
  <div class="custom-alert-overlay" id="customAlertOverlay">
    <div class="custom-alert-content">
      <p id="customAlertMessage"></p>
      <button id="customAlertOkBtn">OK</button>
    </div>
  </div>

  <script type="module">
    // Firebase configuration and initialization
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, getDoc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDpS-kqwQDgdqiVK2kwXGB9a3B7WeJI_Iw",
      authDomain: "unimap-petanque.firebaseapp.com",
      projectId: "unimap-petanque",
      storageBucket: "unimap-petanque.appspot.com",
      messagingSenderId: "578920021890",
      appId: "1:578920021890:web:987ed2de28e7b0353c999b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Define groups array
    const groups = ["A", "B", "C", "D", "E", "F"];

    // --- Custom Modal Functions ---
    /**
     * Displays a custom confirmation modal and returns a Promise that resolves to true (confirmed) or false (cancelled).
     * @param {string} title - The title of the confirmation modal.
     * @param {string} message - The message displayed in the confirmation modal.
     * @returns {Promise<boolean>} Resolves to true if confirmed, false if cancelled.
     */
    function showConfirmModal(title, message) {
        return new Promise((resolve) => {
            const overlay = document.getElementById('confirmModalOverlay');
            const titleElement = document.getElementById('confirmModalTitle');
            const messageElement = document.getElementById('confirmModalMessage');
            const confirmBtn = document.getElementById('confirmModalConfirmBtn');
            const cancelBtn = document.getElementById('confirmModalCancelBtn');

            titleElement.textContent = title;
            messageElement.textContent = message;

            // Clear previous event listeners to prevent multiple firings
            const cloneConfirmBtn = confirmBtn.cloneNode(true);
            const cloneCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(cloneConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(cloneCancelBtn, cancelBtn);

            cloneConfirmBtn.addEventListener('click', () => {
                overlay.classList.remove('visible');
                resolve(true); // User confirmed
            });

            cloneCancelBtn.addEventListener('click', () => {
                overlay.classList.remove('visible');
                resolve(false); // User cancelled
            });

            overlay.classList.add('visible');
        });
    }

    /**
     * Displays a custom alert modal.
     * @param {string} message - The message to display in the alert.
     */
    function showAlertModal(message) {
        const overlay = document.getElementById('customAlertOverlay');
        const messageElement = document.getElementById('customAlertMessage');
        const okBtn = document.getElementById('customAlertOkBtn');

        messageElement.textContent = message;

        // Clear previous event listeners for OK button
        const cloneOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(cloneOkBtn, okBtn);

        cloneOkBtn.addEventListener('click', () => {
            overlay.classList.remove('visible');
        });

        overlay.classList.add('visible');
    }
    // --- End Custom Modal Functions ---


    // Make switchTab globally accessible
    window.switchTab = function(tabId) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      // Find the tab element by its onclick attribute to apply active class
      const targetTabElement = document.querySelector(`.tab[onclick*="switchTab('${tabId}')"]`);
      // Special handling for Homepage tab as it uses window.location.href
      if (tabId === 'homepage') {
          document.querySelector(`.tab[onclick*="window.location.href='index.html'"]`).classList.add('active');
      } else if (targetTabElement) {
          targetTabElement.classList.add('active');
      }
      document.getElementById(tabId).classList.add('active');

      // Refresh data when switching tabs
      if (tabId === 'groupStage') {
          displayGroupStageMatches();
      } else if (tabId === 'nextStage') {
          fetchNextStageData();
      }
    }

    // Helper function to compare team standings for sorting.
    function compareTeamStandings(a, b) {
        if (b.points !== a.points) return b.points - a.points;
        if (b.difference !== a.difference) return b.difference - a.difference;
        if (b.scoreFor !== a.scoreFor) return b.scoreFor - a.scoreFor;
        return a.teamName.localeCompare(b.teamName);
    }

    // Fetches and processes all group stage data
    async function getGroupStageData() {
        const result = {
            standingsByGroup: {},
            matchesByGroup: {},
            teamsByGroup: {},
            venuesByGroup: {} // Only venue data now
        };

        const teamsSnapshot = await getDocs(collection(db, "teams"));
        teamsSnapshot.forEach(doc => {
            const data = doc.data();
            const group = data.group;
            const teamName = data.teamName;
            if (group && teamName) {
                if (!result.teamsByGroup[group]) result.teamsByGroup[group] = [];
                result.teamsByGroup[group].push(teamName);
            }
        });

        for (const group of groups) {
            const groupDocRef = doc(db, "matchResults", group);
            const groupDocSnap = await getDoc(groupDocRef);

            const groupTeams = result.teamsByGroup[group] || [];
            groupTeams.sort();

            const standings = {};
            groupTeams.forEach(teamName => {
                standings[teamName] = {
                    teamName: teamName,
                    played: 0, wins: 0, losses: 0, draws: 0,
                    points: 0, scoreFor: 0, scoreAgainst: 0, difference: 0
                };
            });

            if (groupDocSnap.exists()) { // Check if document exists
                const data = groupDocSnap.data();
                const matches = data.matches || {};
                result.matchesByGroup[group] = matches;
                result.venuesByGroup[group] = data.venue || ''; // Get venue
                
                for (const matchKey in matches) {
                    if (matches.hasOwnProperty(matchKey)) {
                        const scoreStr = matches[matchKey];
                        const parts = matchKey.replace(/_/g, ' ').split(' vs ');
                        let teamA = parts[0] ? parts[0].trim() : null;
                        let teamB = parts[1] ? parts[1].trim() : null;

                        if (!teamA || !teamB || !standings[teamA] || !standings[teamB]) {
                            console.warn(`Skipping match ${matchKey} in group ${group}: Team data not found or invalid.`);
                            continue;
                        }

                        const scoreParts = scoreStr.split('-');
                        if (scoreParts.length === 2) {
                            let scoreA = parseInt(scoreParts[0]);
                            let scoreB = parseInt(scoreParts[1]);

                            if (!isNaN(scoreA) && !isNaN(scoreB)) {
                                standings[teamA].played++; standings[teamB].played++;
                                standings[teamA].scoreFor += scoreA; standings[teamA].scoreAgainst += scoreB;
                                standings[teamB].scoreFor += scoreB; standings[teamB].scoreAgainst += scoreA;

                                if (scoreA > scoreB) {
                                    standings[teamA].wins++; standings[teamB].losses++; standings[teamA].points += 3;
                                } else if (scoreB > scoreA) {
                                    standings[teamB].wins++; standings[teamA].losses++; standings[teamB].points += 3;
                                } else {
                                    standings[teamA].draws++; standings[teamB].draws++;
                                    standings[teamA].points += 1; standings[teamB].points += 1;
                                }
                            }
                        }
                    }
                }
            }

            let sortedStandings = Object.values(standings).map(teamStat => {
                teamStat.difference = teamStat.scoreFor - teamStat.scoreAgainst;
                return teamStat;
            }).sort(compareTeamStandings);

            result.standingsByGroup[group] = sortedStandings;
        }
        return result;
    }

    // Fetches and displays data for the Next Stage (Quarter, Semi, Final).
    async function fetchNextStageData() {
        try {
            const { standingsByGroup } = await getGroupStageData();

            let groupWinners = [];
            let allRunnersUp = [];

            for (const group of groups) {
                const groupStandings = standingsByGroup[group];
                // Ensure there's a winner before pushing
                if (groupStandings && groupStandings.length >= 1 && groupStandings[0].teamName !== "TBD") {
                    groupWinners.push(groupStandings[0]); // Winner is rank 0
                }
                // Ensure there's a runner-up before pushing
                if (groupStandings && groupStandings.length >= 2 && groupStandings[1].teamName !== "TBD") {
                    allRunnersUp.push(groupStandings[1]); // Runner-up is rank 1
                }
            }

            allRunnersUp.sort(compareTeamStandings);
            const top2RunnersUp = allRunnersUp.slice(0, 2); // Get the best 2 runners-up

            let qualifiers = [...groupWinners, ...top2RunnersUp];
            qualifiers.sort(compareTeamStandings); // Sort all 8 qualifiers (6 winners + 2 runners-up)

            // Fetch actual knockout match results if they exist (for SF/Final)
            const knockoutMatchesData = {
                quarter_finals: [],
                semi_finals: [],
                final: []
            };

            const qfSnapshot = await getDocs(collection(db, "knockoutMatches", "quarter_finals", "matches"));
            qfSnapshot.forEach(doc => knockoutMatchesData.quarter_finals.push({ id: doc.id, ...doc.data() })); // Store doc.id
            
            const sfSnapshot = await getDocs(collection(db, "knockoutMatches", "semi_finals", "matches"));
            sfSnapshot.forEach(doc => knockoutMatchesData.semi_finals.push({ id: doc.id, ...doc.data() })); // Store doc.id
            
            const finalSnapshot = await getDocs(collection(db, "knockoutMatches", "final", "matches"));
            finalSnapshot.forEach(doc => knockoutMatchesData.final.push({ id: doc.id, ...doc.data() })); // Store doc.id


            // --- Quarter Finals ---
            let qfHtml = "";
            const qfLabels = ["QF1", "QF2", "QF3", "QF4"];
            let qfWinners = {}; // To store QF winners for SF matchups

            // Define QF pairings based on sorted qualifiers.
            // These are the *potential* teams that *should* play.
            const qfPotentialPairings = [
                { teamA: qualifiers[0] || null, teamB: qualifiers[7] || null }, // Rank 1 vs Rank 8
                { teamA: qualifiers[3] || null, teamB: qualifiers[4] || null }, // Rank 4 vs Rank 5
                { teamA: qualifiers[1] || null, teamB: qualifiers[6] || null }, // Rank 2 vs Rank 7
                { teamA: qualifiers[2] || null, teamB: qualifiers[5] || null }  // Rank 3 vs Rank 6
            ];
            
            qfPotentialPairings.forEach((pairing, index) => {
                const label = qfLabels[index];
                // Use the label as the Firestore document ID for consistency
                const firebaseMatchId = label; 

                let displayTeamA = "TBD";
                let displayTeamB = "TBD";
                let scoreA = '';
                let scoreB = '';
                let venue = "";
                let time = "";
                let isNoData = false; // Controls the 'no-data-message' class
                
                // saveButtonDisabled based on whether the potential teams are actually known
                let saveButtonDisabled = (pairing.teamA === null || pairing.teamB === null || 
                                          (pairing.teamA && pairing.teamA.teamName === "TBD") || (pairing.teamB && pairing.teamB.teamName === "TBD"));

                // Try to find existing match data for this specific QF label (e.g., QF1)
                const matchData = knockoutMatchesData.quarter_finals.find(m => m.id === firebaseMatchId);

                if (matchData && matchData.teamA && matchData.teamB) { // If match data exists and has valid team names
                    displayTeamA = matchData.teamA;
                    displayTeamB = matchData.teamB;
                    scoreA = matchData.scoreA || '';
                    scoreB = matchData.scoreB || '';
                    venue = matchData.venue || "";
                    time = matchData.time || "";
                    saveButtonDisabled = false; // Enable saving if data exists (even if scores are empty)
                } else {
                    isNoData = true; // Mark as no data if no match found in Firebase for this label
                    // If no data, keep display as TBD and inputs disabled unless actual teams are identified
                    if (pairing.teamA && pairing.teamA.teamName && pairing.teamA.teamName !== "TBD" &&
                        pairing.teamB && pairing.teamB.teamName && pairing.teamB.teamName !== "TBD") {
                        // If potential teams are known but no data saved, show potential teams,
                        // and enable the save button because teams are now known.
                        displayTeamA = pairing.teamA.teamName;
                        displayTeamB = pairing.teamB.teamName;
                        saveButtonDisabled = false; // ENABLE if actual teams are known
                    } else {
                        // If teams are still TBD/null from qualifiers, keep disabled
                        saveButtonDisabled = true;
                    }
                }
                
                // Determine winner for SF pairing based on saved data, or TBD if not available
                let winner = "TBD";
                if (matchData && !isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                    if (matchData.scoreA > matchData.scoreB) {
                        winner = matchData.teamA;
                    } else if (matchData.scoreB > matchData.scoreA) {
                        winner = matchData.teamB;
                    } else {
                        winner = "DRAW"; // Should not happen in Petanque
                    }
                }
                qfWinners[label] = winner; // Store the winner for SF pairing

                qfHtml += `<div class="bracket-match ${isNoData ? 'no-data-message' : ''}">
                                <p class="teams">${label}: ${displayTeamA} vs ${displayTeamB}</p>
                                <p class="score">Score: 
                                    <input type="number" id="${firebaseMatchId}_scoreA" class="score-input" value="${scoreA}" min="0" ${saveButtonDisabled ? 'disabled' : ''}> - 
                                    <input type="number" id="${firebaseMatchId}_scoreB" class="score-input" value="${scoreB}" min="0" ${saveButtonDisabled ? 'disabled' : ''}>
                                </p>
                                <p class="venue-time">Venue: 
                                    <input type="text" id="${firebaseMatchId}_venue" class="text-input" value="${venue}" ${saveButtonDisabled ? 'disabled' : ''}> Time: 
                                    <input type="text" id="${firebaseMatchId}_time" class="text-input" value="${time}" ${saveButtonDisabled ? 'disabled' : ''}>
                                </p>
                                <div class="match-edit-controls">
                                    <button class="save-button" ${saveButtonDisabled ? 'disabled' : ''} 
                                            onclick="window.saveKnockoutMatch('quarter_finals', '${firebaseMatchId}', 
                                            '${displayTeamA}', '${displayTeamB}')">Save</button>
                                </div>
                            </div>`;
            });
            
            // Display a message if not enough qualifiers for QF
            if (qualifiers.length < 8) {
                qfHtml += `<div class="bracket-match no-data-message" style="margin-top: 10px;">
                                <p>Only ${qualifiers.length}/8 teams qualified so far. Complete group stage to generate Quarter Final matches.</p>
                            </div>`;
            }
            document.getElementById('quarterFinals').innerHTML = qfHtml;

            // --- Semi Finals ---
            let sfHtml = "";
            const sfLabels = ["SF1", "SF2"];
            let sfWinners = {}; // To store SF winners for Final matchup

            // Determine SF pairings based on QF winners (actual determined winners or "TBD")
            const sfPotentialPairings = [
                { teamA: qfWinners["QF1"], teamB: qfWinners["QF2"] },
                { teamA: qfWinners["QF3"], teamB: qfWinners["QF4"] }
            ];

            for (let i = 0; i < 2; i++) {
                const label = sfLabels[i];
                // Use the label as the Firestore document ID
                const firebaseMatchId = label;

                let displayTeamA = "TBD";
                let displayTeamB = "TBD";
                let scoreA = '';
                let scoreB = '';
                let venue = "";
                let time = "";
                let isNoData = false;    
                
                // saveButtonDisabled if potential teams are TBD or DRAW
                let saveButtonDisabled = (sfPotentialPairings[i].teamA === "TBD" || sfPotentialPairings[i].teamB === "TBD" || 
                                          sfPotentialPairings[i].teamA === "DRAW" || sfPotentialPairings[i].teamB === "DRAW");

                const matchData = knockoutMatchesData.semi_finals.find(m => m.id === firebaseMatchId);
                
                if (matchData && matchData.teamA && matchData.teamB) { // If match data exists and has valid team names
                    displayTeamA = matchData.teamA;
                    displayTeamB = matchData.teamB;
                    scoreA = matchData.scoreA || '';
                    scoreB = matchData.scoreB || '';
                    venue = matchData.venue || "";
                    time = matchData.time || "";
                    saveButtonDisabled = false; // Enable saving if data exists
                } else {
                    isNoData = true; // Mark as no data if no match found in Firebase for this label
                    // If potential teams are known, display them even if no data saved
                    if (sfPotentialPairings[i].teamA !== "TBD" && sfPotentialPairings[i].teamB !== "TBD" &&
                        sfPotentialPairings[i].teamA !== "DRAW" && sfPotentialPairings[i].teamB !== "DRAW") {
                        displayTeamA = sfPotentialPairings[i].teamA;
                        displayTeamB = sfPotentialPairings[i].teamB;
                        saveButtonDisabled = false; // Enable the save button if actual teams are known
                    } else {
                        // If teams are still TBD/DRAW from QF winners, keep disabled
                        saveButtonDisabled = true;
                    }
                }

                // Determine winner for Final pairing
                let winner = "TBD";
                if (matchData && !isNaN(parseInt(matchData.scoreA)) && !isNaN(parseInt(matchData.scoreB))) {
                    if (matchData.scoreA > matchData.scoreB) {
                        winner = matchData.teamA;
                    } else if (matchData.scoreB > matchData.scoreA) {
                        winner = matchData.teamB;
                    } else {
                        winner = "DRAW";
                    }
                }
                sfWinners[label] = winner; // Store SF winner

                sfHtml += `<div class="bracket-match ${isNoData ? 'no-data-message' : ''}">
                                <p class="teams">${label}: ${displayTeamA} vs ${displayTeamB}</p>
                                <p class="score">Score: 
                                    <input type="number" id="${firebaseMatchId}_scoreA" class="score-input" value="${scoreA}" min="0" ${saveButtonDisabled ? 'disabled' : ''}> - 
                                    <input type="number" id="${firebaseMatchId}_scoreB" class="score-input" value="${scoreB}" min="0" ${saveButtonDisabled ? 'disabled' : ''}>
                                </p>
                                <p class="venue-time">Venue: 
                                    <input type="text" id="${firebaseMatchId}_venue" class="text-input" value="${venue}" ${saveButtonDisabled ? 'disabled' : ''}> Time: 
                                    <input type="text" id="${firebaseMatchId}_time" class="text-input" value="${time}" ${saveButtonDisabled ? 'disabled' : ''}>
                                </p>
                                <div class="match-edit-controls">
                                    <button class="save-button" ${saveButtonDisabled ? 'disabled' : ''} 
                                            onclick="window.saveKnockoutMatch('semi_finals', '${firebaseMatchId}', 
                                            '${displayTeamA}', '${displayTeamB}')">Save</button>
                                </div>
                            </div>`;
            }
            document.getElementById('semiFinals').innerHTML = sfHtml;

            // --- Final ---
            let finalHtml = "";
            const finalLabel = "Final";
            // Determine Final pairing based on SF winners (actual determined winners or "TBD")
            const finalPotentialPairing = { teamA: sfWinners["SF1"], teamB: sfWinners["SF2"] };

            // Use the label as the Firestore document ID
            const firebaseMatchId_final = finalLabel;

            let displayTeamA_final = "TBD";
            let displayTeamB_final = "TBD";
            let scoreA_final = '';
            let scoreB_final = '';
            let venue_final = "";
            let time_final = "";
            let isFinalNoData = false;
            
            let finalSaveButtonDisabled = (finalPotentialPairing.teamA === "TBD" || finalPotentialPairing.teamB === "TBD" ||
                                           finalPotentialPairing.teamA === "DRAW" || finalPotentialPairing.teamB === "DRAW");

            const finalMatchData = knockoutMatchesData.final.find(m => m.id === firebaseMatchId_final); // Find by fixed ID
            
            if (finalMatchData && finalMatchData.teamA && finalMatchData.teamB) { // If match data exists and has valid team names
                displayTeamA_final = finalMatchData.teamA;
                displayTeamB_final = finalMatchData.teamB;
                scoreA_final = finalMatchData.scoreA || '';
                scoreB_final = finalMatchData.scoreB || '';
                venue_final = finalMatchData.venue || "";
                time_final = finalMatchData.time || "";
                finalSaveButtonDisabled = false; // Enable saving if data exists
            } else {
                isFinalNoData = true; // Mark as no data if no match found in Firebase for this label
                // If potential teams are known, display them even if no data saved
                if (finalPotentialPairing.teamA !== "TBD" && finalPotentialPairing.teamB !== "TBD" &&
                    finalPotentialPairing.teamA !== "DRAW" && finalPotentialPairing.teamB !== "DRAW") {
                    displayTeamA_final = finalPotentialPairing.teamA;
                    displayTeamB_final = finalPotentialPairing.teamB;
                    finalSaveButtonDisabled = false; // Enable the save button if actual teams are known
                } else {
                    // If teams are still TBD/DRAW from SF winners, keep disabled
                    finalSaveButtonDisabled = true;
                }
            }

            finalHtml += `<div class="bracket-match ${isFinalNoData ? 'no-data-message' : ''}">
                                <p class="teams">${finalLabel}: ${displayTeamA_final} vs ${displayTeamB_final}</p>
                                <p class="score">Score: 
                                    <input type="number" id="${firebaseMatchId_final}_scoreA" class="score-input" value="${scoreA_final}" min="0" ${finalSaveButtonDisabled ? 'disabled' : ''}> - 
                                    <input type="number" id="${firebaseMatchId_final}_scoreB" class="score-input" value="${scoreB_final}" min="0" ${finalSaveButtonDisabled ? 'disabled' : ''}>
                                </p>
                                <p class="venue-time">Venue: 
                                    <input type="text" id="${firebaseMatchId_final}_venue" class="text-input" value="${venue_final}" ${finalSaveButtonDisabled ? 'disabled' : ''}> Time: 
                                    <input type="text" id="${firebaseMatchId_final}_time" class="text-input" value="${time_final}" ${finalSaveButtonDisabled ? 'disabled' : ''}>
                                </p>
                                <div class="match-edit-controls">
                                    <button class="save-button" ${finalSaveButtonDisabled ? 'disabled' : ''} 
                                            onclick="window.saveKnockoutMatch('final', '${firebaseMatchId_final}', 
                                            '${displayTeamA_final}', '${displayTeamB_final}')">Save</button>
                                </div>
                            </div>`;
            
            document.getElementById('finalMatch').innerHTML = finalHtml;

        } catch (error) {
            console.error("Error fetching Next Stage data: ", error);
            document.getElementById('quarterFinals').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Quarter Final data.</p></div>`;
            document.getElementById('semiFinals').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Semi Final data.</p></div>`;
            document.getElementById('finalMatch').innerHTML = `<div class="bracket-match no-data-message"><p>Error loading Final data.</p></div>`;
        }
    }

    // Function to save all Group Stage match results
    window.saveAllGroupMatches = async function(group) {
        try {
            const groupDocRef = doc(db, "matchResults", group);
            const groupDocSnap = await getDoc(groupDocRef);
            let currentMatches = groupDocSnap.exists() ? groupDocSnap.data().matches || {} : {};
            let updatedMatches = { ...currentMatches };

            // Get venue input
            const venueInput = document.getElementById(`${group}_venue`).value;
            

            const teamsSnapshot = await getDocs(collection(db, "teams"));
            const teamsByGroup = {};
            teamsSnapshot.forEach(doc => {
                const data = doc.data();
                const groupName = data.group;
                const teamName = data.teamName;
                if (groupName && teamName) {
                    if (!teamsByGroup[groupName]) teamsByGroup[groupName] = [];
                    teamsByGroup[groupName].push(teamName);
                }
            });

            const groupTeams = teamsByGroup[group] || [];
            groupTeams.sort();

            for (let i = 0; i < groupTeams.length; i++) {
                for (let j = i + 1; j < groupTeams.length; j++) {
                    const teamA = groupTeams[i];
                    const teamB = groupTeams[j];
                    // MatchKey always sorted alphabetically to ensure consistency in DB
                    const matchKey = teamA < teamB ? `${teamA.replace(/\s/g, '_')} vs ${teamB.replace(/\s/g, '_')}` : `${teamB.replace(/\s/g, '_')} vs ${teamA.replace(/\s/g, '_')}`;

                    const scoreA = document.getElementById(`${group}_${matchKey}_scoreA`).value;
                    const scoreB = document.getElementById(`${group}_${matchKey}_scoreB`).value;

                    // Only update if both scores are numbers and not empty
                    if (!isNaN(parseInt(scoreA)) && !isNaN(parseInt(scoreB)) && scoreA.trim() !== "" && scoreB.trim() !== "") {
                        // Store scores in alphabetical order of teams for consistency
                        let finalScoreA = parseInt(scoreA);
                        let finalScoreB = parseInt(scoreB);
                        if (teamA > teamB) { // If teamA was actually B and teamB was A in the display
                            [finalScoreA, finalScoreB] = [finalScoreB, finalScoreA];
                        }
                        updatedMatches[matchKey] = `${finalScoreA}-${finalScoreB}`;
                    } else if (updatedMatches.hasOwnProperty(matchKey)) {
                        // If scores are cleared, remove them from updatedMatches
                        delete updatedMatches[matchKey];
                    }
                }
            }
            // Save matches and venue
            await setDoc(groupDocRef, { matches: updatedMatches, venue: venueInput }, { merge: true });
            showAlertModal(`Match results and group details for Group ${group} saved successfully!`);
            displayGroupStageMatches(); // Refresh data after saving
        } catch (error) {
            console.error(`Error saving match results for Group ${group}: `, error);
            showAlertModal(`Error saving results for Group ${group}. Please try again.`);
        }
    };

    // Function to save knockout stage match results
    // teamA and teamB arguments here are the *actual qualified* team names, not "TBD"
    window.saveKnockoutMatch = async function(stage, firebaseMatchId, actualTeamA, actualTeamB) {
        try {
            const scoreA = document.getElementById(`${firebaseMatchId}_scoreA`).value;
            const scoreB = document.getElementById(`${firebaseMatchId}_scoreB`).value;
            const venue = document.getElementById(`${firebaseMatchId}_venue`).value;
            const time = document.getElementById(`${firebaseMatchId}_time`).value;

            if (isNaN(parseInt(scoreA)) || isNaN(parseInt(scoreB)) || scoreA.trim() === "" || scoreB.trim() === "") {
                showAlertModal("Please enter valid numerical scores for both teams.");
                return;
            }
            
            // Add validation for actualTeamA and actualTeamB
            if (actualTeamA === "TBD" || actualTeamB === "TBD" || actualTeamA === "DRAW" || actualTeamB === "DRAW") {
                showAlertModal("Cannot save. Teams are still undetermined from previous stages.");
                return;
            }

            const matchData = {
                teamA: actualTeamA, // Save actual qualified team names
                teamB: actualTeamB, // Save actual qualified team names
                scoreA: parseInt(scoreA),
                scoreB: parseInt(scoreB),
                venue: venue,
                time: time,
                timestamp: new Date()
            };

            const matchDocRef = doc(db, "knockoutMatches", stage, "matches", firebaseMatchId);
            await setDoc(matchDocRef, matchData, { merge: true });
            showAlertModal(`Match results for ${stage.replace('_', ' ').toUpperCase()} saved successfully!`);
            fetchNextStageData(); // Reload data after saving
        } catch (error) {
            console.error(`Error saving knockout match for ${stage}: `, error);
            showAlertModal(`Error saving knockout match for ${stage}. Please try again.`);
        }
    };

    // Main function to display group stage matches
    async function displayGroupStageMatches() {
        const { matchesByGroup, teamsByGroup, venuesByGroup } = await getGroupStageData(); // Removed timesByGroup
        const matchMatrixDiv = document.getElementById("matchMatrix");
        matchMatrixDiv.innerHTML = ""; // Clear previous content

        if (Object.keys(teamsByGroup).length === 0) {
            matchMatrixDiv.innerHTML = "<p style='text-align: center; color: #666;'>No teams registered yet. Please register teams on the Group Draw page.</p>";
            return;
        }

        for (const group of groups) {
            const groupTeams = teamsByGroup[group] || [];
            groupTeams.sort(); // Ensure consistent order
            const currentVenue = venuesByGroup[group] || '';
            // currentTime removed

            let groupHtml = `
                <h3 style="color: #007bff;">Group ${group}</h3>
                <div class="group-info-inputs">
                    <label for="${group}_venue">Venue:</label>
                    <input type="text" id="${group}_venue" class="text-input" value="${currentVenue}" placeholder="Enter Venue">
                </div>
                <table class="match-matrix-table">
                    <thead>
                        <tr>
                            <th></th>`;
            groupTeams.forEach(team => {
                groupHtml += `<th>${team}</th>`;
            });
            groupHtml += `
                        </tr>
                    </thead>
                    <tbody>`;

            for (let i = 0; i < groupTeams.length; i++) {
                const teamA = groupTeams[i];
                groupHtml += `
                        <tr>
                            <th>${teamA}</th>`;
                for (let j = 0; j < groupTeams.length; j++) {
                    const teamB = groupTeams[j];
                    if (teamA === teamB) {
                        groupHtml += `<td class="empty-cell"></td>`; // Empty cell for self-match
                    } else {
                        // MatchKey is always sorted alphabetically to ensure consistency in DB
                        const matchKey = teamA < teamB ? `${teamA.replace(/\s/g, '_')} vs ${teamB.replace(/\s/g, '_')}` : `${teamB.replace(/\s/g, '_')} vs ${teamA.replace(/\s/g, '_')}`;
                        
                        let scoreA = '';
                        let scoreB = '';
                        if (matchesByGroup[group] && matchesByGroup[group][matchKey]) {
                           const scores = matchesByGroup[group][matchKey].split('-');
                           // Ensure scores are assigned to the correct teams based on display order
                           if (teamA < teamB) { // If teamA comes first in the sorted key (key is A vs B)
                               scoreA = scores[0];
                               scoreB = scores[1];
                           } else { // If teamB comes first in the sorted key (key is B vs A)
                               scoreA = scores[1];
                               scoreB = scores[0];
                           }
                        }

                        groupHtml += `
                            <td>
                                <input type="number" id="${group}_${matchKey}_scoreA" class="score-input" value="${scoreA}" min="0"> -
                                <input type="number" id="${group}_${matchKey}_scoreB" class="score-input" value="${scoreB}" min="0">
                            </td>`;
                    }
                }
                groupHtml += `
                        </tr>`;
            }
            groupHtml += `
                    </tbody>
                </table>
                <div class="match-edit-controls">
                    <button class="save-button" onclick="window.saveAllGroupMatches('${group}')">Save Group ${group} Results</button>
                </div>
            `;
            matchMatrixDiv.innerHTML += groupHtml;
        }
    }

    // Function to reset all game data (match results and knockout stages)
    window.resetGameData = async function() {
        const resetStatusDiv = document.getElementById("resetStatus");
        resetStatusDiv.textContent = ""; // Clear previous status

        const confirmed = await showConfirmModal(
            "Reset All Data?",
            "Are you sure you want to reset ALL match data (Group Stage & Knockout)? This action cannot be undone."
        );
        
        if (!confirmed) {
            resetStatusDiv.textContent = "Reset cancelled.";
            resetStatusDiv.style.color = "orange";
            return;
        }

        resetStatusDiv.textContent = "Resetting data... Please wait.";
        resetStatusDiv.style.color = "blue";

        try {
            // 1. Delete Group Stage match results
            for (const group of groups) {
                const groupDocRef = doc(db, "matchResults", group);
                await deleteDoc(groupDocRef).catch(e => console.warn(`Doc for group ${group} not found or error deleting:`, e));
            }
            console.log("Group Stage match results deleted.");

            // 2. Delete Knockout Stage match results
            const knockoutStages = ["quarter_finals", "semi_finals", "final"];
            for (const stage of knockoutStages) {
                const matchesCollectionRef = collection(db, "knockoutMatches", stage, "matches");
                const matchesSnapshot = await getDocs(matchesCollectionRef);
                const deletePromises = [];
                matchesSnapshot.forEach(docToDelete => {
                    deletePromises.push(deleteDoc(doc(db, "knockoutMatches", stage, "matches", docToDelete.id)));
                });
                await Promise.all(deletePromises);
                console.log(`${stage.replace('_', ' ').toUpperCase()} matches deleted.`);
            }

            resetStatusDiv.textContent = "âœ… All match data successfully reset!";
            resetStatusDiv.style.color = "green";

            // Reload displayed data on the page
            displayGroupStageMatches();
            fetchNextStageData();

        } catch (error) {
            console.error("Error resetting game data: ", error);
            resetStatusDiv.textContent = "â— Error occurred during reset. Please check console.";
            resetStatusDiv.style.color = "red";
        }
    };


    // Initial data load when the page is loaded
    document.addEventListener("DOMContentLoaded", () => {
        // Display Group Stage matches initially
        displayGroupStageMatches();
        // Pre-load Next Stage data in the background, but only display when tab is active
        // fetchNextStageData(); // This is now called when the tab is switched, no need to call here.
    });
  </script>
</body>
</html>
